# Linux Interview Questions


## 查看系统负载的常用命令

```bash
[root@centos6 ~ 10:56 #37]# w
10:57:38 up 14 min,  1 user,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.147.1    18:44    0.00s  0.10s  0.00s w
[root@centos6 ~ 10:57 #38]# uptime
10:57:47 up 14 min,  1 user,  load average: 0.00, 0.00, 0.00
```
其中load average即系统负载，三个数值分别表示一分钟、五分钟、十五分钟内系统的平均负载，即平均任务数。

## linux系统里，知道buffer和cache如何区分吗？

buffer和cache都是内存中的一块区域，当CPU需要写数据到磁盘时，由于磁盘速度比较慢，所以CPU先把数据存进buffer，然后CPU去执行其他任务，buffer中的数据会定期写入磁盘；当CPU需要从磁盘读入数据时，由于磁盘速度比较慢，可以把即将用到的数据提前存入cache，CPU直接从Cache中拿数据要快的多。

## 常用的查看系统资源的命令

top, free

- VIRT虚拟内存用量
- RES物理内存用量
- SHR共享内存用量
- %MEM内存用量

## 查看当前系统进程
ps -aux

## ps 查看系统进程时，有一列为STAT， 如果当前进程的stat为Ss 表示什么含义？如果为Z表示什么含义？

S表示正在休眠；s表示主进程；Z表示僵尸进程。

## 有一天你突然发现公司网站访问速度变的很慢很慢，你该怎么办呢？

（服务器可以登陆，提示：你可以从系统负载和网卡流量入手）

答：可以从两个方面入手分析：分析系统负载，使用w命令或者uptime命令查看系统负载，如果负载很高，则使用top命令查看CPU，MEM等占用情况，要么是CPU繁忙，要么是内存不够，如果这二者都正常，再去使用sar命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。

## 孤儿进程与僵尸进程

https://www.cnblogs.com/Anker/p/3271773.html

在Linux/Unix中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是异步的，即父进程永远无法预测子进程会在什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用`wait()`或者`waitpid()`系统调用取得子进程的终止状态。

**孤儿进程：** 一个父进程退出，而它的一个或者多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被`init`进程（PID为1）所收养，并由`init`进程对它们完成状态收集工作。

**僵尸进程：** 一个进程使用`fork`创建子进程，如果子进程退出，而父进程没用调用`wait`或`waitpid`获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程便称为僵尸进程。

Unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是：当每个进程退出时，内核释放该进程所有的资源，包括打开的文件，占用的内存等，但是仍然为其保留一定的信息，包括进程号（process ID），退出状态，CPU使用时间等。直到父进程通过`wait`/`waitpid`来取时才释放。但是这样就导致了问题，如果进程不调用`wait`/`waitpid`的话，那么保留的那些信息就不会释放，比如进程号一直被占用，而系统所能使用的进程号是有限的，如果系统中存在大量僵尸进程，系统将会因为没有可用的进程号而导致系统不能产生新的进程。**这就是僵尸进程的危害。**

而孤儿进程是没有父进程的进程，孤儿进程的进程号等信息将由`init`进程释放。当孤儿进程结束退出时，`init`进程将进行进程号等信息的回收，所以**孤儿进程不会有什么危害。**

任何一个子进程（`init`除外）在`exit()`之后，并不会马上消失，而是留下一个称为僵尸进程Zombie的数据结构，等待父进程处理。

如果系统中有个进程在不断地产生新的进程，但是在子进程结束时并没有进行清理，便会产生**大量**僵尸进程。僵尸进程并非问题的根源，问题的根源在于产生这些子进程的父进程。当需要**清理系统中大量的僵尸进程时**，就需要把**父进程杀掉**（kill SIGTERM or SIGKILL），在父进程被杀掉之后，之前那些僵尸进程便成了孤儿进程，**由init进程接管并进行资源回收**。
