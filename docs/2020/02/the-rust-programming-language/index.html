<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>The Rust Programming Language | Forgetful :/</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noodp" />
<meta name="Description" content="Notes about everything"><link rel="prev" href="https://murray-liang.github.io/forgetful/2020/02/tooz/" /><link rel="next" href="https://murray-liang.github.io/forgetful/2020/02/design-topics/" /><link rel="canonical" href="https://murray-liang.github.io/forgetful/2020/02/the-rust-programming-language/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"><meta property="og:title" content="The Rust Programming Language" />
<meta property="og:description" content="Chap 3 Common Programming Concept 3.1 Variables and Mutability By default variables are immutable.
Immutable variables vs. Constants: Constants are valid for the entire time a program runs, within the scope they were declared in, making them a useful choice for values in your application domain that multiple parts of the program might need to know about.
Shadowing: We can shadow a variable by using the same variable’s name and repeating the use of the let keyword." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://murray-liang.github.io/forgetful/2020/02/the-rust-programming-language/" />
<meta property="article:published_time" content="2020-02-10T16:37:31+08:00" />
<meta property="article:modified_time" content="2020-02-10T16:37:31+08:00" />
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "The Rust Programming Language",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/murray-liang.github.io\/forgetful\/2020\/02\/the-rust-programming-language\/"
        },"image": {
                "@type": "ImageObject",
                "url": "https:\/\/murray-liang.github.io\/forgetful\/cover.png",
                "width":  800 ,
                "height":  600 
            },"genre": "posts","keywords": "rust, the rust programming language, trpl","wordcount":  21727 ,
        "url": "https:\/\/murray-liang.github.io\/forgetful\/2020\/02\/the-rust-programming-language\/","datePublished": "2020-02-10T16:37:31\x2b08:00","dateModified": "2020-02-10T16:37:31\x2b08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
                "@type": "Organization",
                "name": "murray",
                "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/murray-liang.github.io\/forgetful\/logo.png",
                "width":  127 ,
                "height":  40 
                }
            },"description": ""
    }
    </script><link rel="stylesheet" href="/forgetful/css/style.min.css"><link rel="stylesheet" href="/forgetful/css/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/forgetful/css/lib/forkawesome/forkawesome.min.css"><link rel="stylesheet" href="/forgetful/css/lib/animate/animate.min.css"></head>
    <body><script>
            if (!window.localStorage || !window.localStorage.getItem('theme')) {
                window.isDark = 'dark' === 'dark';
            } else {
                window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            }
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><nav class="navbar">
    <div class="navbar-container">
        <div class="navbar-header animated bounceIn">
            <a href="https://murray-liang.github.io/forgetful">Forgetful :/</a>
        </div>
        <div class="navbar-menu"><a class="menu-item" href="https://murray-liang.github.io/forgetful/posts" title="">Posts</a><a class="menu-item" href="https://murray-liang.github.io/forgetful/tags" title="">Tags</a><a class="menu-item" href="https://murray-liang.github.io/forgetful/categories" title="">Categories</a><a class="menu-item" href="https://murray-liang.github.io/forgetful/about" title="">About</a><a class="menu-item" href="https://github.com/Murray-LIANG/forgetful" title="简体中文"><i class="fas fa-language fa-fw"></i></a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a>
        </div>
    </div>
</nav><nav class="navbar-mobile">
    <div class="navbar-container">
        <div class="navbar-header">
            <div class="navbar-header-title animated bounceIn">
                <a href="https://murray-liang.github.io/forgetful">Forgetful :/</a>
            </div>
            <div class="menu-toggle" id="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="navbar-menu" id="mobile-menu"><a class="menu-item" href="https://murray-liang.github.io/forgetful/posts" title="">Posts</a><a class="menu-item" href="https://murray-liang.github.io/forgetful/tags" title="">Tags</a><a class="menu-item" href="https://murray-liang.github.io/forgetful/categories" title="">Categories</a><a class="menu-item" href="https://murray-liang.github.io/forgetful/about" title="">About</a><a class="menu-item" href="https://github.com/Murray-LIANG/forgetful" title="简体中文"></a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a>
        </div>
    </div>
</nav>
<main class="main">
                <div class="container"><article class="page"><h1 class="post-title animated flipInX">The Rust Programming Language</h1><div class="post-meta">
            <div class="post-meta-main"><a class="author" href="https://github.com/Murray-LIANG" rel="author" target="_blank">
                    <i class="fas fa-user-circle fa-fw"></i>Murray-LIANG
                </a>&nbsp;</div>
            <div class="post-meta-other"><i class="far fa-calendar-alt fa-fw"></i><time datetime=2020-02-10>2020-02-10</time>&nbsp;
                <i class="fas fa-pencil-alt fa-fw"></i>about 21727 words&nbsp;
                <i class="far fa-clock fa-fw"></i>103 min&nbsp;</div>
        </div><div class="post-toc" id="post-toc">
                <h2 class="post-toc-title">Contents</h2>
                <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#chap-3-common-programming-concept">Chap 3 Common Programming Concept</a>
      <ul>
        <li><a href="#31-variables-and-mutability">3.1 Variables and Mutability</a></li>
        <li><a href="#32-data-types">3.2 Data Types</a></li>
        <li><a href="#33-functions">3.3 Functions</a>
          <ul>
            <li><a href="#function-bodies-contain-statements-and-expressions">Function Bodies Contain Statements and Expressions</a></li>
          </ul>
        </li>
        <li><a href="#34-control-flows">3.4 Control Flows</a>
          <ul>
            <li><a href="#use-if-in-a-let-statement">Use if in a let Statement</a></li>
            <li><a href="#return-values-from-loops">Return Values from Loops</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#chap-4-understanding-ownership">Chap 4 Understanding Ownership</a>
      <ul>
        <li><a href="#what-is-ownership">What Is Ownership?</a>
          <ul>
            <li><a href="#ways-to-manage-a-computers-memory">Ways to manage a computer&rsquo;s memory</a></li>
            <li><a href="#the-heap-vs-the-stack">The Heap vs. The Stack</a></li>
            <li><a href="#ownership-rules">Ownership Rules</a></li>
            <li><a href="#memory-and-allocation">Memory and Allocation</a></li>
            <li><a href="#ownership-and-functions">Ownership and Functions</a></li>
            <li><a href="#return-values-and-scope">Return Values and Scope</a></li>
          </ul>
        </li>
        <li><a href="#42-references-and-borrowing">4.2 References and Borrowing</a>
          <ul>
            <li><a href="#mutable-references">Mutable References</a></li>
          </ul>
        </li>
        <li><a href="#43-the-slice-type">4.3 The Slice Type</a>
          <ul>
            <li><a href="#string-slices">String Slices</a></li>
            <li><a href="#string-literals-are-slices">String Literals Are Slices</a></li>
            <li><a href="#string-slices-as-parameters">String Slices as Parameters</a></li>
            <li><a href="#other-slices">Other Slices</a></li>
            <li><a href="#the-concepts-of-ownership-borrowing-and-slices-ensure-memory-safety-in-rust-programs-at-compile-time">The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time.</a></li>
            <li><a href="#the-rust-language-gives-you-control-over-your-memory-usage-in-the-same-way-as-other-systems-programming-languages-but-having-the-owner-of-data-automatically-clean-up-that-data-when-the-owner-goes-out-of-scope-means-you-dont-have-to-write-and-debug-extra-code-to-get-this-control">The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#chap-5-using-structs-to-structure-related-data">Chap 5 Using Structs to Structure Related Data</a>
      <ul>
        <li><a href="#51-structs">5.1 Structs</a></li>
        <li><a href="#53-methods">5.3 Methods</a></li>
      </ul>
    </li>
    <li><a href="#6-enums">6 Enums</a>
      <ul>
        <li><a href="#62-the-match-control-flow-operator">6.2 The match Control Flow Operator</a>
          <ul>
            <li><a href="#patterns-that-bind-to-values">Patterns that Bind to Values</a></li>
            <li><a href="#the-_-placeholder">The _ Placeholder</a></li>
          </ul>
        </li>
        <li><a href="#63-concise-control-flow-with-if-let">6.3 Concise Control Flow with if let</a></li>
      </ul>
    </li>
    <li><a href="#7-managing-growing-projects-with-packages-crates-and-modules">7 Managing Growing Projects with Packages, Crates, and Modules</a>
      <ul>
        <li><a href="#packages">Packages</a></li>
        <li><a href="#crates">Crates</a></li>
        <li><a href="#modules">Modules</a></li>
        <li><a href="#paths">Paths</a>
          <ul>
            <li><a href="#use-a-relative-or-absolute-path-our-preference-is-to-specify-absolute-paths-because-its-more-likely-to-move-code-definitions-and-item-calls-independently-of-each-other">Use a relative or absolute path? Our preference is to specify absolute paths because it’s more likely to move code definitions and item calls independently of each other.</a></li>
            <li><a href="#items-in-a-parent-module-cant-use-the-private-items-inside-child-modules-but-items-in-child-modules-can-use-the-items-in-their-ancestor-modules">Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.</a></li>
            <li><a href="#if-we-use-pub-before-a-struct-definition-we-make-the-struct-public-but-the-structs-fields-will-still-be-private">If we use pub before a struct definition, we make the struct public, but the struct&rsquo;s fields will still be private.</a></li>
            <li><a href="#in-contrast-if-we-make-an-enum-public-all-of-its-variants-are-then-public">In contrast, if we make an enum public, all of its variants are then public.</a></li>
          </ul>
        </li>
        <li><a href="#use-keyword">use Keyword</a></li>
        <li><a href="#separating-modules-into-different-files">Separating Modules into Different Files</a></li>
      </ul>
    </li>
    <li><a href="#8-common-collections">8 Common Collections</a>
      <ul>
        <li><a href="#vectors">Vectors</a>
          <ul>
            <li><a href="#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></li>
          </ul>
        </li>
        <li><a href="#strings">Strings</a>
          <ul>
            <li><a href="#understand--operator">Understand + operator</a></li>
            <li><a href="#indexing-into-strings">Indexing into Strings</a></li>
            <li><a href="#bytes-and-scalar-values-and-grapheme-clusters">Bytes and Scalar Values and Grapheme Clusters</a></li>
            <li><a href="#slicing-strings">Slicing Strings</a></li>
            <li><a href="#methods-for-iterating-over-strings">Methods for Iterating Over Strings</a></li>
          </ul>
        </li>
        <li><a href="#83-hash-maps">8.3 Hash Maps</a>
          <ul>
            <li><a href="#only-inserting-a-value-if-the-key-has-no-value">Only Inserting a Value If the Key Has No Value</a></li>
            <li><a href="#updating-a-value-based-on-the-old-value">Updating a Value Based on the Old Value</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#9-error-handling">9 Error Handling</a>
      <ul>
        <li><a href="#rust-has-no-exceptions">Rust has no exceptions.</a></li>
        <li><a href="#panic">panic!</a>
          <ul>
            <li><a href="#about-unwinding-the-stack">About unwinding the stack</a></li>
          </ul>
        </li>
        <li><a href="#result">Result</a>
          <ul>
            <li><a href="#how-do-we-know-a-methodfunction-returns-a-result">How do we know a method/function returns a Result?</a></li>
            <li><a href="#matching-on-different-errors-using-errorkind">Matching on different errors using error.kind().</a></li>
            <li><a href="#shortcuts-for-panic-on-error-unwrap-and-expect">Shortcuts for panic on error: unwrap and expect.</a></li>
            <li><a href="#propagating-errors">Propagating Errors</a></li>
            <li><a href="#-operator">? Operator</a></li>
            <li><a href="#-can-only-be-used-in-functions-that-return-result">? Can Only Be Used in Functions That Return Result</a></li>
          </ul>
        </li>
        <li><a href="#93-to-panic-or-not-to-panic">9.3 To panic! or Not to panic!</a>
          <ul>
            <li><a href="#use-unwrap-and-expect-to-panic-when-youre-writing-an-example-prototype-or-test-codes">Use unwrap and expect to panic when you&rsquo;re writing an example, prototype or test codes.</a></li>
            <li><a href="#use-unwrap-and-expect-to-panic-when-youre-writing-codes-which-are-logically-impossible-to-fail">Use unwrap and expect to panic when you&rsquo;re writing codes which are logically impossible to fail.</a></li>
            <li><a href="#guidelines-for-error-handling">Guidelines for Error Handling</a></li>
            <li><a href="#creating-custom-types-for-validation">Creating Custom Types for Validation</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#10-generic">10 Generic</a>
      <ul>
        <li><a href="#101-generic-data-types">10.1 Generic Data Types</a>
          <ul>
            <li><a href="#in-function-definitions">In Function Definitions</a></li>
            <li><a href="#in-struct-definitions">In Struct Definitions</a></li>
            <li><a href="#in-enum-definitions">In Enum Definitions</a></li>
            <li><a href="#in-method-definitions">In Method Definitions</a></li>
            <li><a href="#performance-of-code-using-generics">Performance of Code Using Generics</a></li>
          </ul>
        </li>
        <li><a href="#102-traits-defining-shared-behavior">10.2 Traits: Defining Shared Behavior</a>
          <ul>
            <li><a href="#defining-a-trait">Defining a Trait</a></li>
            <li><a href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type</a></li>
            <li><a href="#restrictions-with-trait-implementations">Restrictions with Trait Implementations</a></li>
            <li><a href="#default-implementations">Default Implementations</a></li>
            <li><a href="#traits-as-parameters">Traits as Parameters</a></li>
            <li><a href="#trait-bound-syntax">Trait Bound Syntax</a></li>
            <li><a href="#specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the + Syntax</a></li>
            <li><a href="#clearer-trait-bounds-with-where-clauses">Clearer Trait Bounds with where Clauses</a></li>
            <li><a href="#returning-types-that-implement-traits">Returning Types that Implement Traits</a></li>
            <li><a href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></li>
          </ul>
        </li>
        <li><a href="#103-validating-references-with-lifetimes">10.3 Validating References with Lifetimes</a>
          <ul>
            <li><a href="#the-borrow-checker">The Borrow Checker</a></li>
            <li><a href="#generic-lifetimes-in-functions">Generic Lifetimes in Functions</a></li>
            <li><a href="#lifetime-annotation-syntax">Lifetime Annotation Syntax</a></li>
            <li><a href="#lifetime-annotations-in-function-signatures">Lifetime Annotations in Function Signatures</a></li>
            <li><a href="#lifetime-annotations-in-struct-definitions">Lifetime Annotations in Struct Definitions</a></li>
            <li><a href="#lifetime-elision">Lifetime Elision</a></li>
            <li><a href="#the-static-lifetime">The Static Lifetime</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#11-writing-automated-tests">11 Writing Automated Tests</a>
      <ul>
        <li><a href="#111-how-to-write-tests">11.1 How to Write Tests</a>
          <ul>
            <li><a href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></li>
            <li><a href="#checking-for-panics-with-should_panic">Checking for Panics with should_panic</a></li>
            <li><a href="#using-resultt-e-in-tests">Using Result<T, E> in Tests</a></li>
          </ul>
        </li>
        <li><a href="#112-controlling-how-tests-are-run">11.2 Controlling How Tests Are Run</a>
          <ul>
            <li><a href="#running-a-subset-of-tests-by-name">Running a Subset of Tests by Name</a></li>
            <li><a href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></li>
          </ul>
        </li>
        <li><a href="#113-test-organization">11.3 Test Organization</a>
          <ul>
            <li><a href="#ut---testing-one-module-in-isolation-at-a-time-and-can-test-private-interfaces">UT - testing one module in isolation at a time, and can test private interfaces.</a></li>
            <li><a href="#it---entirely-external-to-your-library-and-use-your-code-in-the-same-way-any-other-external-code-would-using-only-the-public-interface-and-potentially-exercising-multiple-modules-per-test">IT - entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</a></li>
            <li><a href="#unit-tests">Unit Tests</a></li>
            <li><a href="#the-tests-module-and-cfgtest">The Tests Module and #[cfg(test)]</a></li>
            <li><a href="#integration-tests">Integration Tests</a></li>
            <li><a href="#integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#12-an-io-project-building-a-command-line-program">12 An I/O Project: Building a Command Line Program</a>
      <ul>
        <li><a href="#123-refactoring-to-improve-modularity-and-error-handling">12.3 Refactoring to Improve Modularity and Error Handling</a>
          <ul>
            <li><a href="#guideline-for-splitting-the-separate-concerns-of-a-binary-program-when-main-starts-getting-large">Guideline for splitting the separate concerns of a binary program when main starts getting large.</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#13-functional-language-features-iterators-and-closures">13 Functional Language Features: Iterators and Closures</a>
      <ul>
        <li><a href="#131-closures-anonymous-functions-that-can-capture-their-environment">13.1 Closures: Anonymous Functions that Can Capture Their Environment</a>
          <ul>
            <li><a href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></li>
            <li><a href="#storing-closures-using-generic-parameters-and-the-fn-traits">Storing Closures Using Generic Parameters and the Fn Traits</a></li>
            <li><a href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></li>
          </ul>
        </li>
        <li><a href="#132-processing-a-series-of-items-with-iterators">13.2 Processing a Series of Items with Iterators</a>
          <ul>
            <li><a href="#methods-that-consume-the-iterator">Methods that Consume the Iterator</a></li>
            <li><a href="#methods-that-produce-other-iterators">Methods that Produce Other Iterators</a></li>
            <li><a href="#creating-our-own-iterators-with-the-iterator-trait">Creating Our Own Iterators with the Iterator Trait</a></li>
            <li><a href="#using-other-iterator-trait-methods">Using Other Iterator Trait Methods</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#14-cargo-and-cratesio">14 Cargo and Crates.io</a>
      <ul>
        <li><a href="#142-publishing-a-crate-to-cratesio">14.2 Publishing a Crate to Crates.io</a>
          <ul>
            <li><a href="#making-useful-documentation-comments">Making Useful Documentation Comments</a></li>
            <li><a href="#commenting-contained-items">Commenting Contained Items</a></li>
            <li><a href="#exporting-a-convenient-public-api-with-pub-use">Exporting a Convenient Public API with pub use</a></li>
          </ul>
        </li>
        <li><a href="#145-extending-cargo-with-custom-commands">14.5 Extending Cargo with Custom Commands</a></li>
      </ul>
    </li>
    <li><a href="#15-smart-pointers">15 Smart Pointers</a>
      <ul>
        <li><a href="#151-using-boxt-to-point-to-data-on-the-heap">15.1 Using Box<T> to Point to Data on the Heap</a>
          <ul>
            <li><a href="#using-a-boxt-to-store-data-on-the-heap">Using a Box<T> to Store Data on the Heap</a></li>
            <li><a href="#enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</a></li>
          </ul>
        </li>
        <li><a href="#152-treating-smart-pointers-like-regular-references-with-the-deref-trait">15.2 Treating Smart Pointers Like Regular References with the Deref Trait</a>
          <ul>
            <li><a href="#defining-our-own-smart-pointer">Defining Our Own Smart Pointer</a></li>
            <li><a href="#treating-a-type-like-a-reference-by-implementing-the-deref-trait">Treating a Type Like a Reference by Implementing the Deref Trait</a></li>
            <li><a href="#implicit-deref-coercions-with-functions-and-methods">Implicit Deref Coercions with Functions and Methods</a></li>
          </ul>
        </li>
        <li><a href="#153-running-code-on-cleanup-with-the-drop-trait">15.3 Running Code on Cleanup with the Drop Trait</a>
          <ul>
            <li><a href="#dropping-a-value-early-with-stdmemdrop">Dropping a Value Early with std::mem::drop</a></li>
          </ul>
        </li>
        <li><a href="#154-rct-the-reference-counted-smart-pointer">15.4 Rc<T>, the Reference Counted Smart Pointer</a>
          <ul>
            <li><a href="#using-rct-to-share-data">Using Rc<T> to Share Data</a></li>
          </ul>
        </li>
        <li><a href="#155-refcellt-and-the-interior-mutability-pattern">15.5 RefCell<T> and the Interior Mutability Pattern</a>
          <ul>
            <li><a href="#boxt-vs-rct-vs-refcellt">Box<T> vs. Rc<T> vs. RefCell<T></a></li>
            <li><a href="#a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects</a></li>
            <li><a href="#keeping-track-of-borrows-at-runtime-with-refcellt">Keeping Track of Borrows at Runtime with RefCell<T></a></li>
            <li><a href="#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T></a></li>
          </ul>
        </li>
        <li><a href="#156-reference-cycles-can-leak-memory">15.6 Reference Cycles Can Leak Memory</a>
          <ul>
            <li><a href="#creating-a-reference-cycle">Creating a Reference Cycle</a></li>
            <li><a href="#preventing-reference-cycles-turning-an-rct-into-a-weakt">Preventing Reference Cycles: Turning an Rc<T> into a Weak<T></a></li>
            <li><a href="#summary">Summary</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#16-fearless-concurrency">16 Fearless Concurrency</a>
      <ul>
        <li><a href="#161-using-threads-to-run-code-simultaneously">16.1 Using Threads to Run Code Simultaneously</a>
          <ul>
            <li><a href="#creating-a-new-thread-with-spawn">Creating a New Thread with spawn</a></li>
            <li><a href="#waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finish Using join Handles</a></li>
            <li><a href="#using-move-closures-with-threads">Using move Closures with Threads</a></li>
          </ul>
        </li>
        <li><a href="#162-using-message-passing-to-transfer-data-between-threads">16.2 Using Message Passing to Transfer Data Between Threads</a>
          <ul>
            <li><a href="#creating-multiple-producers-by-cloning-the-transmitter">Creating Multiple Producers by Cloning the Transmitter</a></li>
          </ul>
        </li>
        <li><a href="#163-shared-state-concurrency">16.3 Shared-State Concurrency</a>
          <ul>
            <li><a href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time">Using Mutexes to Allow Access to Data from One Thread at a Time</a></li>
            <li><a href="#multiple-ownership-with-multiple-threads">Multiple Ownership with Multiple Threads</a></li>
            <li><a href="#similarities-between-refcelltrct-and-mutextarct">Similarities Between RefCell<T>/Rc<T> and Mutex<T>/Arc<T></a></li>
          </ul>
        </li>
        <li><a href="#164-extensible-concurrency-with-the-sync-and-send-traits">16.4 Extensible Concurrency with the Sync and Send Traits</a>
          <ul>
            <li><a href="#allowing-transference-of-ownership-between-threads-with-send">Allowing Transference of Ownership Between Threads with Send</a></li>
            <li><a href="#allowing-access-from-multiple-threads-with-sync">Allowing Access from Multiple Threads with Sync</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#17-object-oriented-programming-features-of-rust">17 Object Oriented Programming Features of Rust</a>
      <ul>
        <li><a href="#171-characteristics-of-object-oriented-languages">17.1 Characteristics of Object-Oriented Languages</a>
          <ul>
            <li><a href="#objects-contain-data-and-behavior">Objects Contain Data and Behavior</a></li>
            <li><a href="#encapsulation-that-hides-implementation-details">Encapsulation that Hides Implementation Details</a></li>
            <li><a href="#inheritance-as-a-type-system-and-as-code-sharing">Inheritance as a Type System and as Code Sharing</a></li>
          </ul>
        </li>
        <li><a href="#172-using-trait-objects-that-allow-for-values-of-different-types">17.2 Using Trait Objects That Allow for Values of Different Types</a>
          <ul>
            <li><a href="#defining-a-trait-for-common-behavior">Defining a Trait for Common Behavior</a></li>
            <li><a href="#implementing-the-trait">Implementing the Trait</a></li>
            <li><a href="#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a></li>
            <li><a href="#object-safety-is-required-for-trait-objects">Object Safety Is Required for Trait Objects</a></li>
          </ul>
        </li>
        <li><a href="#173-implementing-an-object-oriented-design-pattern">17.3 Implementing an Object-Oriented Design Pattern</a>
          <ul>
            <li><a href="#we-could-leverage-rusts-type-checking-system-more-to-issue-compiler-errors">We could leverage Rust&rsquo;s type checking system more to issue compiler errors.</a></li>
            <li><a href="#encoding-states-and-behavior-as-types">Encoding States and Behavior as Types</a></li>
            <li><a href="#implementing-transitions-as-transformations-into-different-types">Implementing Transitions as Transformations into Different Types</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#18-patterns-and-matching">18 Patterns and Matching</a>
      <ul>
        <li><a href="#181-all-the-places-patterns-can-be-used">18.1 All the Places Patterns Can Be Used</a>
          <ul>
            <li><a href="#match-arms">match Arms</a></li>
            <li><a href="#conditional-if-let-expressions">Conditional if let Expressions</a></li>
            <li><a href="#while-let-conditional-loops">while let Conditional Loops</a></li>
            <li><a href="#for-loops">for Loops</a></li>
            <li><a href="#let-statements">let Statements</a></li>
            <li><a href="#function-parameters">Function Parameters</a></li>
          </ul>
        </li>
        <li><a href="#182-refutability-whether-a-pattern-might-fail-to-match">18.2 Refutability: Whether a Pattern Might Fail to Match</a></li>
        <li><a href="#183-pattern-syntax">18.3 Pattern Syntax</a>
          <ul>
            <li><a href="#matching-literals">Matching Literals</a></li>
            <li><a href="#matching-named-variables">Matching Named Variables</a></li>
            <li><a href="#multiple-patterns">Multiple Patterns</a></li>
            <li><a href="#matching-ranges-of-values-with-">Matching Ranges of Values with ..=</a></li>
            <li><a href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></li>
            <li><a href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></li>
            <li><a href="#extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></li>
            <li><a href="#-bindings">@ Bindings</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#19-advanced-features">19 Advanced Features</a>
      <ul>
        <li><a href="#191-unsafe-rust">19.1 Unsafe Rust</a>
          <ul>
            <li><a href="#unsafe-superpowers">Unsafe Superpowers</a></li>
            <li><a href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></li>
            <li><a href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></li>
            <li><a href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></li>
            <li><a href="#using-extern-functions-to-call-external-code">Using extern Functions to Call External Code</a></li>
            <li><a href="#calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></li>
            <li><a href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></li>
            <li><a href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></li>
          </ul>
        </li>
        <li><a href="#193-advance-traits">19.3 Advance Traits</a>
          <ul>
            <li><a href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></li>
            <li><a href="#default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></li>
            <li><a href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></li>
            <li><a href="#using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait’s Functionality Within Another Trait</a></li>
            <li><a href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a></li>
          </ul>
        </li>
        <li><a href="#194-advanced-types">19.4 Advanced Types</a>
          <ul>
            <li><a href="#using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</a></li>
            <li><a href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></li>
            <li><a href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></li>
            <li><a href="#dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the Sized Trait</a></li>
          </ul>
        </li>
        <li><a href="#195-advanced-functions-and-closures">19.5 Advanced Functions and Closures</a>
          <ul>
            <li><a href="#function-pointers">Function Pointers</a></li>
            <li><a href="#returning-closures">Returning Closures</a></li>
          </ul>
        </li>
        <li><a href="#196-macros">19.6 Macros</a>
          <ul>
            <li><a href="#the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></li>
            <li><a href="#declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with macro_rules! for General Metaprogramming</a></li>
            <li><a href="#procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</a></li>
            <li><a href="#how-to-write-a-custom-derive-macro">How to Write a Custom derive Macro</a></li>
            <li><a href="#attribute-like-macros">Attribute-like macros</a></li>
            <li><a href="#function-like-macros">Function-like macros</a></li>
          </ul>
        </li>
        <li><a href="#20-final-project-building-a-multithreaded-web-server">20 Final Project: Building a Multithreaded Web Server</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div>
            <div class="post-toc-mobile" id="post-toc-mobile">
                <details>
                    <summary>
                        <div class="post-toc-title">
                            <span>Contents</span>
                            <span><i class="details icon fas fa-angle-down"></i></span>
                        </div>
                    </summary>
                    <div class="post-toc-content"><nav id="TableOfContentsMobile">
  <ul>
    <li><a href="#chap-3-common-programming-concept">Chap 3 Common Programming Concept</a>
      <ul>
        <li><a href="#31-variables-and-mutability">3.1 Variables and Mutability</a></li>
        <li><a href="#32-data-types">3.2 Data Types</a></li>
        <li><a href="#33-functions">3.3 Functions</a>
          <ul>
            <li><a href="#function-bodies-contain-statements-and-expressions">Function Bodies Contain Statements and Expressions</a></li>
          </ul>
        </li>
        <li><a href="#34-control-flows">3.4 Control Flows</a>
          <ul>
            <li><a href="#use-if-in-a-let-statement">Use if in a let Statement</a></li>
            <li><a href="#return-values-from-loops">Return Values from Loops</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#chap-4-understanding-ownership">Chap 4 Understanding Ownership</a>
      <ul>
        <li><a href="#what-is-ownership">What Is Ownership?</a>
          <ul>
            <li><a href="#ways-to-manage-a-computers-memory">Ways to manage a computer&rsquo;s memory</a></li>
            <li><a href="#the-heap-vs-the-stack">The Heap vs. The Stack</a></li>
            <li><a href="#ownership-rules">Ownership Rules</a></li>
            <li><a href="#memory-and-allocation">Memory and Allocation</a></li>
            <li><a href="#ownership-and-functions">Ownership and Functions</a></li>
            <li><a href="#return-values-and-scope">Return Values and Scope</a></li>
          </ul>
        </li>
        <li><a href="#42-references-and-borrowing">4.2 References and Borrowing</a>
          <ul>
            <li><a href="#mutable-references">Mutable References</a></li>
          </ul>
        </li>
        <li><a href="#43-the-slice-type">4.3 The Slice Type</a>
          <ul>
            <li><a href="#string-slices">String Slices</a></li>
            <li><a href="#string-literals-are-slices">String Literals Are Slices</a></li>
            <li><a href="#string-slices-as-parameters">String Slices as Parameters</a></li>
            <li><a href="#other-slices">Other Slices</a></li>
            <li><a href="#the-concepts-of-ownership-borrowing-and-slices-ensure-memory-safety-in-rust-programs-at-compile-time">The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time.</a></li>
            <li><a href="#the-rust-language-gives-you-control-over-your-memory-usage-in-the-same-way-as-other-systems-programming-languages-but-having-the-owner-of-data-automatically-clean-up-that-data-when-the-owner-goes-out-of-scope-means-you-dont-have-to-write-and-debug-extra-code-to-get-this-control">The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#chap-5-using-structs-to-structure-related-data">Chap 5 Using Structs to Structure Related Data</a>
      <ul>
        <li><a href="#51-structs">5.1 Structs</a></li>
        <li><a href="#53-methods">5.3 Methods</a></li>
      </ul>
    </li>
    <li><a href="#6-enums">6 Enums</a>
      <ul>
        <li><a href="#62-the-match-control-flow-operator">6.2 The match Control Flow Operator</a>
          <ul>
            <li><a href="#patterns-that-bind-to-values">Patterns that Bind to Values</a></li>
            <li><a href="#the-_-placeholder">The _ Placeholder</a></li>
          </ul>
        </li>
        <li><a href="#63-concise-control-flow-with-if-let">6.3 Concise Control Flow with if let</a></li>
      </ul>
    </li>
    <li><a href="#7-managing-growing-projects-with-packages-crates-and-modules">7 Managing Growing Projects with Packages, Crates, and Modules</a>
      <ul>
        <li><a href="#packages">Packages</a></li>
        <li><a href="#crates">Crates</a></li>
        <li><a href="#modules">Modules</a></li>
        <li><a href="#paths">Paths</a>
          <ul>
            <li><a href="#use-a-relative-or-absolute-path-our-preference-is-to-specify-absolute-paths-because-its-more-likely-to-move-code-definitions-and-item-calls-independently-of-each-other">Use a relative or absolute path? Our preference is to specify absolute paths because it’s more likely to move code definitions and item calls independently of each other.</a></li>
            <li><a href="#items-in-a-parent-module-cant-use-the-private-items-inside-child-modules-but-items-in-child-modules-can-use-the-items-in-their-ancestor-modules">Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.</a></li>
            <li><a href="#if-we-use-pub-before-a-struct-definition-we-make-the-struct-public-but-the-structs-fields-will-still-be-private">If we use pub before a struct definition, we make the struct public, but the struct&rsquo;s fields will still be private.</a></li>
            <li><a href="#in-contrast-if-we-make-an-enum-public-all-of-its-variants-are-then-public">In contrast, if we make an enum public, all of its variants are then public.</a></li>
          </ul>
        </li>
        <li><a href="#use-keyword">use Keyword</a></li>
        <li><a href="#separating-modules-into-different-files">Separating Modules into Different Files</a></li>
      </ul>
    </li>
    <li><a href="#8-common-collections">8 Common Collections</a>
      <ul>
        <li><a href="#vectors">Vectors</a>
          <ul>
            <li><a href="#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></li>
          </ul>
        </li>
        <li><a href="#strings">Strings</a>
          <ul>
            <li><a href="#understand--operator">Understand + operator</a></li>
            <li><a href="#indexing-into-strings">Indexing into Strings</a></li>
            <li><a href="#bytes-and-scalar-values-and-grapheme-clusters">Bytes and Scalar Values and Grapheme Clusters</a></li>
            <li><a href="#slicing-strings">Slicing Strings</a></li>
            <li><a href="#methods-for-iterating-over-strings">Methods for Iterating Over Strings</a></li>
          </ul>
        </li>
        <li><a href="#83-hash-maps">8.3 Hash Maps</a>
          <ul>
            <li><a href="#only-inserting-a-value-if-the-key-has-no-value">Only Inserting a Value If the Key Has No Value</a></li>
            <li><a href="#updating-a-value-based-on-the-old-value">Updating a Value Based on the Old Value</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#9-error-handling">9 Error Handling</a>
      <ul>
        <li><a href="#rust-has-no-exceptions">Rust has no exceptions.</a></li>
        <li><a href="#panic">panic!</a>
          <ul>
            <li><a href="#about-unwinding-the-stack">About unwinding the stack</a></li>
          </ul>
        </li>
        <li><a href="#result">Result</a>
          <ul>
            <li><a href="#how-do-we-know-a-methodfunction-returns-a-result">How do we know a method/function returns a Result?</a></li>
            <li><a href="#matching-on-different-errors-using-errorkind">Matching on different errors using error.kind().</a></li>
            <li><a href="#shortcuts-for-panic-on-error-unwrap-and-expect">Shortcuts for panic on error: unwrap and expect.</a></li>
            <li><a href="#propagating-errors">Propagating Errors</a></li>
            <li><a href="#-operator">? Operator</a></li>
            <li><a href="#-can-only-be-used-in-functions-that-return-result">? Can Only Be Used in Functions That Return Result</a></li>
          </ul>
        </li>
        <li><a href="#93-to-panic-or-not-to-panic">9.3 To panic! or Not to panic!</a>
          <ul>
            <li><a href="#use-unwrap-and-expect-to-panic-when-youre-writing-an-example-prototype-or-test-codes">Use unwrap and expect to panic when you&rsquo;re writing an example, prototype or test codes.</a></li>
            <li><a href="#use-unwrap-and-expect-to-panic-when-youre-writing-codes-which-are-logically-impossible-to-fail">Use unwrap and expect to panic when you&rsquo;re writing codes which are logically impossible to fail.</a></li>
            <li><a href="#guidelines-for-error-handling">Guidelines for Error Handling</a></li>
            <li><a href="#creating-custom-types-for-validation">Creating Custom Types for Validation</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#10-generic">10 Generic</a>
      <ul>
        <li><a href="#101-generic-data-types">10.1 Generic Data Types</a>
          <ul>
            <li><a href="#in-function-definitions">In Function Definitions</a></li>
            <li><a href="#in-struct-definitions">In Struct Definitions</a></li>
            <li><a href="#in-enum-definitions">In Enum Definitions</a></li>
            <li><a href="#in-method-definitions">In Method Definitions</a></li>
            <li><a href="#performance-of-code-using-generics">Performance of Code Using Generics</a></li>
          </ul>
        </li>
        <li><a href="#102-traits-defining-shared-behavior">10.2 Traits: Defining Shared Behavior</a>
          <ul>
            <li><a href="#defining-a-trait">Defining a Trait</a></li>
            <li><a href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type</a></li>
            <li><a href="#restrictions-with-trait-implementations">Restrictions with Trait Implementations</a></li>
            <li><a href="#default-implementations">Default Implementations</a></li>
            <li><a href="#traits-as-parameters">Traits as Parameters</a></li>
            <li><a href="#trait-bound-syntax">Trait Bound Syntax</a></li>
            <li><a href="#specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the + Syntax</a></li>
            <li><a href="#clearer-trait-bounds-with-where-clauses">Clearer Trait Bounds with where Clauses</a></li>
            <li><a href="#returning-types-that-implement-traits">Returning Types that Implement Traits</a></li>
            <li><a href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></li>
          </ul>
        </li>
        <li><a href="#103-validating-references-with-lifetimes">10.3 Validating References with Lifetimes</a>
          <ul>
            <li><a href="#the-borrow-checker">The Borrow Checker</a></li>
            <li><a href="#generic-lifetimes-in-functions">Generic Lifetimes in Functions</a></li>
            <li><a href="#lifetime-annotation-syntax">Lifetime Annotation Syntax</a></li>
            <li><a href="#lifetime-annotations-in-function-signatures">Lifetime Annotations in Function Signatures</a></li>
            <li><a href="#lifetime-annotations-in-struct-definitions">Lifetime Annotations in Struct Definitions</a></li>
            <li><a href="#lifetime-elision">Lifetime Elision</a></li>
            <li><a href="#the-static-lifetime">The Static Lifetime</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#11-writing-automated-tests">11 Writing Automated Tests</a>
      <ul>
        <li><a href="#111-how-to-write-tests">11.1 How to Write Tests</a>
          <ul>
            <li><a href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></li>
            <li><a href="#checking-for-panics-with-should_panic">Checking for Panics with should_panic</a></li>
            <li><a href="#using-resultt-e-in-tests">Using Result<T, E> in Tests</a></li>
          </ul>
        </li>
        <li><a href="#112-controlling-how-tests-are-run">11.2 Controlling How Tests Are Run</a>
          <ul>
            <li><a href="#running-a-subset-of-tests-by-name">Running a Subset of Tests by Name</a></li>
            <li><a href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></li>
          </ul>
        </li>
        <li><a href="#113-test-organization">11.3 Test Organization</a>
          <ul>
            <li><a href="#ut---testing-one-module-in-isolation-at-a-time-and-can-test-private-interfaces">UT - testing one module in isolation at a time, and can test private interfaces.</a></li>
            <li><a href="#it---entirely-external-to-your-library-and-use-your-code-in-the-same-way-any-other-external-code-would-using-only-the-public-interface-and-potentially-exercising-multiple-modules-per-test">IT - entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</a></li>
            <li><a href="#unit-tests">Unit Tests</a></li>
            <li><a href="#the-tests-module-and-cfgtest">The Tests Module and #[cfg(test)]</a></li>
            <li><a href="#integration-tests">Integration Tests</a></li>
            <li><a href="#integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#12-an-io-project-building-a-command-line-program">12 An I/O Project: Building a Command Line Program</a>
      <ul>
        <li><a href="#123-refactoring-to-improve-modularity-and-error-handling">12.3 Refactoring to Improve Modularity and Error Handling</a>
          <ul>
            <li><a href="#guideline-for-splitting-the-separate-concerns-of-a-binary-program-when-main-starts-getting-large">Guideline for splitting the separate concerns of a binary program when main starts getting large.</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#13-functional-language-features-iterators-and-closures">13 Functional Language Features: Iterators and Closures</a>
      <ul>
        <li><a href="#131-closures-anonymous-functions-that-can-capture-their-environment">13.1 Closures: Anonymous Functions that Can Capture Their Environment</a>
          <ul>
            <li><a href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></li>
            <li><a href="#storing-closures-using-generic-parameters-and-the-fn-traits">Storing Closures Using Generic Parameters and the Fn Traits</a></li>
            <li><a href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></li>
          </ul>
        </li>
        <li><a href="#132-processing-a-series-of-items-with-iterators">13.2 Processing a Series of Items with Iterators</a>
          <ul>
            <li><a href="#methods-that-consume-the-iterator">Methods that Consume the Iterator</a></li>
            <li><a href="#methods-that-produce-other-iterators">Methods that Produce Other Iterators</a></li>
            <li><a href="#creating-our-own-iterators-with-the-iterator-trait">Creating Our Own Iterators with the Iterator Trait</a></li>
            <li><a href="#using-other-iterator-trait-methods">Using Other Iterator Trait Methods</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#14-cargo-and-cratesio">14 Cargo and Crates.io</a>
      <ul>
        <li><a href="#142-publishing-a-crate-to-cratesio">14.2 Publishing a Crate to Crates.io</a>
          <ul>
            <li><a href="#making-useful-documentation-comments">Making Useful Documentation Comments</a></li>
            <li><a href="#commenting-contained-items">Commenting Contained Items</a></li>
            <li><a href="#exporting-a-convenient-public-api-with-pub-use">Exporting a Convenient Public API with pub use</a></li>
          </ul>
        </li>
        <li><a href="#145-extending-cargo-with-custom-commands">14.5 Extending Cargo with Custom Commands</a></li>
      </ul>
    </li>
    <li><a href="#15-smart-pointers">15 Smart Pointers</a>
      <ul>
        <li><a href="#151-using-boxt-to-point-to-data-on-the-heap">15.1 Using Box<T> to Point to Data on the Heap</a>
          <ul>
            <li><a href="#using-a-boxt-to-store-data-on-the-heap">Using a Box<T> to Store Data on the Heap</a></li>
            <li><a href="#enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</a></li>
          </ul>
        </li>
        <li><a href="#152-treating-smart-pointers-like-regular-references-with-the-deref-trait">15.2 Treating Smart Pointers Like Regular References with the Deref Trait</a>
          <ul>
            <li><a href="#defining-our-own-smart-pointer">Defining Our Own Smart Pointer</a></li>
            <li><a href="#treating-a-type-like-a-reference-by-implementing-the-deref-trait">Treating a Type Like a Reference by Implementing the Deref Trait</a></li>
            <li><a href="#implicit-deref-coercions-with-functions-and-methods">Implicit Deref Coercions with Functions and Methods</a></li>
          </ul>
        </li>
        <li><a href="#153-running-code-on-cleanup-with-the-drop-trait">15.3 Running Code on Cleanup with the Drop Trait</a>
          <ul>
            <li><a href="#dropping-a-value-early-with-stdmemdrop">Dropping a Value Early with std::mem::drop</a></li>
          </ul>
        </li>
        <li><a href="#154-rct-the-reference-counted-smart-pointer">15.4 Rc<T>, the Reference Counted Smart Pointer</a>
          <ul>
            <li><a href="#using-rct-to-share-data">Using Rc<T> to Share Data</a></li>
          </ul>
        </li>
        <li><a href="#155-refcellt-and-the-interior-mutability-pattern">15.5 RefCell<T> and the Interior Mutability Pattern</a>
          <ul>
            <li><a href="#boxt-vs-rct-vs-refcellt">Box<T> vs. Rc<T> vs. RefCell<T></a></li>
            <li><a href="#a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects</a></li>
            <li><a href="#keeping-track-of-borrows-at-runtime-with-refcellt">Keeping Track of Borrows at Runtime with RefCell<T></a></li>
            <li><a href="#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T></a></li>
          </ul>
        </li>
        <li><a href="#156-reference-cycles-can-leak-memory">15.6 Reference Cycles Can Leak Memory</a>
          <ul>
            <li><a href="#creating-a-reference-cycle">Creating a Reference Cycle</a></li>
            <li><a href="#preventing-reference-cycles-turning-an-rct-into-a-weakt">Preventing Reference Cycles: Turning an Rc<T> into a Weak<T></a></li>
            <li><a href="#summary">Summary</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#16-fearless-concurrency">16 Fearless Concurrency</a>
      <ul>
        <li><a href="#161-using-threads-to-run-code-simultaneously">16.1 Using Threads to Run Code Simultaneously</a>
          <ul>
            <li><a href="#creating-a-new-thread-with-spawn">Creating a New Thread with spawn</a></li>
            <li><a href="#waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finish Using join Handles</a></li>
            <li><a href="#using-move-closures-with-threads">Using move Closures with Threads</a></li>
          </ul>
        </li>
        <li><a href="#162-using-message-passing-to-transfer-data-between-threads">16.2 Using Message Passing to Transfer Data Between Threads</a>
          <ul>
            <li><a href="#creating-multiple-producers-by-cloning-the-transmitter">Creating Multiple Producers by Cloning the Transmitter</a></li>
          </ul>
        </li>
        <li><a href="#163-shared-state-concurrency">16.3 Shared-State Concurrency</a>
          <ul>
            <li><a href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time">Using Mutexes to Allow Access to Data from One Thread at a Time</a></li>
            <li><a href="#multiple-ownership-with-multiple-threads">Multiple Ownership with Multiple Threads</a></li>
            <li><a href="#similarities-between-refcelltrct-and-mutextarct">Similarities Between RefCell<T>/Rc<T> and Mutex<T>/Arc<T></a></li>
          </ul>
        </li>
        <li><a href="#164-extensible-concurrency-with-the-sync-and-send-traits">16.4 Extensible Concurrency with the Sync and Send Traits</a>
          <ul>
            <li><a href="#allowing-transference-of-ownership-between-threads-with-send">Allowing Transference of Ownership Between Threads with Send</a></li>
            <li><a href="#allowing-access-from-multiple-threads-with-sync">Allowing Access from Multiple Threads with Sync</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#17-object-oriented-programming-features-of-rust">17 Object Oriented Programming Features of Rust</a>
      <ul>
        <li><a href="#171-characteristics-of-object-oriented-languages">17.1 Characteristics of Object-Oriented Languages</a>
          <ul>
            <li><a href="#objects-contain-data-and-behavior">Objects Contain Data and Behavior</a></li>
            <li><a href="#encapsulation-that-hides-implementation-details">Encapsulation that Hides Implementation Details</a></li>
            <li><a href="#inheritance-as-a-type-system-and-as-code-sharing">Inheritance as a Type System and as Code Sharing</a></li>
          </ul>
        </li>
        <li><a href="#172-using-trait-objects-that-allow-for-values-of-different-types">17.2 Using Trait Objects That Allow for Values of Different Types</a>
          <ul>
            <li><a href="#defining-a-trait-for-common-behavior">Defining a Trait for Common Behavior</a></li>
            <li><a href="#implementing-the-trait">Implementing the Trait</a></li>
            <li><a href="#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a></li>
            <li><a href="#object-safety-is-required-for-trait-objects">Object Safety Is Required for Trait Objects</a></li>
          </ul>
        </li>
        <li><a href="#173-implementing-an-object-oriented-design-pattern">17.3 Implementing an Object-Oriented Design Pattern</a>
          <ul>
            <li><a href="#we-could-leverage-rusts-type-checking-system-more-to-issue-compiler-errors">We could leverage Rust&rsquo;s type checking system more to issue compiler errors.</a></li>
            <li><a href="#encoding-states-and-behavior-as-types">Encoding States and Behavior as Types</a></li>
            <li><a href="#implementing-transitions-as-transformations-into-different-types">Implementing Transitions as Transformations into Different Types</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#18-patterns-and-matching">18 Patterns and Matching</a>
      <ul>
        <li><a href="#181-all-the-places-patterns-can-be-used">18.1 All the Places Patterns Can Be Used</a>
          <ul>
            <li><a href="#match-arms">match Arms</a></li>
            <li><a href="#conditional-if-let-expressions">Conditional if let Expressions</a></li>
            <li><a href="#while-let-conditional-loops">while let Conditional Loops</a></li>
            <li><a href="#for-loops">for Loops</a></li>
            <li><a href="#let-statements">let Statements</a></li>
            <li><a href="#function-parameters">Function Parameters</a></li>
          </ul>
        </li>
        <li><a href="#182-refutability-whether-a-pattern-might-fail-to-match">18.2 Refutability: Whether a Pattern Might Fail to Match</a></li>
        <li><a href="#183-pattern-syntax">18.3 Pattern Syntax</a>
          <ul>
            <li><a href="#matching-literals">Matching Literals</a></li>
            <li><a href="#matching-named-variables">Matching Named Variables</a></li>
            <li><a href="#multiple-patterns">Multiple Patterns</a></li>
            <li><a href="#matching-ranges-of-values-with-">Matching Ranges of Values with ..=</a></li>
            <li><a href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></li>
            <li><a href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></li>
            <li><a href="#extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></li>
            <li><a href="#-bindings">@ Bindings</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#19-advanced-features">19 Advanced Features</a>
      <ul>
        <li><a href="#191-unsafe-rust">19.1 Unsafe Rust</a>
          <ul>
            <li><a href="#unsafe-superpowers">Unsafe Superpowers</a></li>
            <li><a href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></li>
            <li><a href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></li>
            <li><a href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></li>
            <li><a href="#using-extern-functions-to-call-external-code">Using extern Functions to Call External Code</a></li>
            <li><a href="#calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></li>
            <li><a href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></li>
            <li><a href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></li>
          </ul>
        </li>
        <li><a href="#193-advance-traits">19.3 Advance Traits</a>
          <ul>
            <li><a href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></li>
            <li><a href="#default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></li>
            <li><a href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></li>
            <li><a href="#using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait’s Functionality Within Another Trait</a></li>
            <li><a href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a></li>
          </ul>
        </li>
        <li><a href="#194-advanced-types">19.4 Advanced Types</a>
          <ul>
            <li><a href="#using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</a></li>
            <li><a href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></li>
            <li><a href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></li>
            <li><a href="#dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the Sized Trait</a></li>
          </ul>
        </li>
        <li><a href="#195-advanced-functions-and-closures">19.5 Advanced Functions and Closures</a>
          <ul>
            <li><a href="#function-pointers">Function Pointers</a></li>
            <li><a href="#returning-closures">Returning Closures</a></li>
          </ul>
        </li>
        <li><a href="#196-macros">19.6 Macros</a>
          <ul>
            <li><a href="#the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></li>
            <li><a href="#declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with macro_rules! for General Metaprogramming</a></li>
            <li><a href="#procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</a></li>
            <li><a href="#how-to-write-a-custom-derive-macro">How to Write a Custom derive Macro</a></li>
            <li><a href="#attribute-like-macros">Attribute-like macros</a></li>
            <li><a href="#function-like-macros">Function-like macros</a></li>
          </ul>
        </li>
        <li><a href="#20-final-project-building-a-multithreaded-web-server">20 Final Project: Building a Multithreaded Web Server</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                </details>
            </div><div class="post-content"><a class="post-dummy-target" id="chap-3-common-programming-concept"></a><h2>Chap 3 Common Programming Concept</h2>
<a class="post-dummy-target" id="31-variables-and-mutability"></a><h3>3.1 Variables and Mutability</h3>
<p>By default variables are immutable.</p>
<p>Immutable variables vs. Constants: Constants are valid for the entire time a program runs, within the scope they were declared in, making them a useful choice for values in your application domain that multiple parts of the program might need to know about.</p>
<p>Shadowing: We can shadow a variable by using the same variable’s name and repeating the use of the <code>let</code> keyword.</p>
<a class="post-dummy-target" id="32-data-types"></a><h3>3.2 Data Types</h3>
<p>Rust is a <strong>statically typed language</strong>, which means that it must know the types of all variables at compile time.</p>
<p><strong>Scalar Types</strong>: integers, floating-point numbers, booleans and characters. Rust&rsquo;s <code>char</code> type is four bytes in size and represents a Unicode Scalar value.</p>
<p><strong>Compound Types</strong>, two primitive compound types: tuples and arrays.</p>
<p>Tuples have a fixed length: once declared, they cannot grow or shrink in size. We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">tup</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mf">6.4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">five_hundred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Arrays in Rust are different from arrays in some other languages because arrays in Rust have a <strong>fixed length</strong> like tuples. Arrays are useful when <strong>you want your data allocated on the stack rather than the heap</strong> or when <strong>you want to ensure you always have a fixed number of elements</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="p">;</span><span class="w">  </span><span class="c1">// a is with 5 elements of i32 type.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="p">;</span><span class="w">  </span><span class="c1">// same as let b = [3, 3, 3, 3, 3]
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="33-functions"></a><h3>3.3 Functions</h3>
<a class="post-dummy-target" id="function-bodies-contain-statements-and-expressions"></a><h4>Function Bodies Contain Statements and Expressions</h4>
<p><strong>Statements</strong> are instructions that perform some action and do not return a value. <strong>Expressions</strong> evaluate to a resulting value.</p>
<p>Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, <code>{}</code>, is an expression, for example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The value of y is: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Note the <code>x + 1</code> line without a semicolon at the end, which is unlike most of the lines you’ve seen so far. <strong>Expressions do not include ending semicolons.</strong> If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value. Keep this in mind as you explore function return values and expressions next.</p>
<a class="post-dummy-target" id="34-control-flows"></a><h3>3.4 Control Flows</h3>
<a class="post-dummy-target" id="use-if-in-a-let-statement"></a><h4>Use <code>if</code> in a <code>let</code> Statement</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="mi">5</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="mi">6</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The value of number is: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="return-values-from-loops"></a><h4>Return Values from Loops</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="k">break</span><span class="w"> </span><span class="nl"></span><span class="n">counter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The result is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="chap-4-understanding-ownership"></a><h2>Chap 4 Understanding Ownership</h2>
<a class="post-dummy-target" id="what-is-ownership"></a><h3>What Is Ownership?</h3>
<a class="post-dummy-target" id="ways-to-manage-a-computers-memory"></a><h4>Ways to manage a computer&rsquo;s memory</h4>
<ol>
<li>The language has garbage collection that constantly looks for no longer used memory as the program runs;</li>
<li>The programmer must explicitly allocate and free the memory;</li>
<li>Rust&rsquo;s ownership approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time.</li>
</ol>
<a class="post-dummy-target" id="the-heap-vs-the-stack"></a><h4>The Heap vs. The Stack</h4>
<p>In many programming languages, you don&rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions.</p>
<p>The stack:</p>
<ol>
<li>Adding data is called <code>pushing onto the stack</code>.</li>
<li>FIFO.</li>
<li>All data stored on the stack must have a known, fixed size.</li>
<li>Pushing to the stack is faster than allocating on the heap. Just put at the top of the stack.</li>
<li>Accessing is faster.</li>
</ol>
<p>The heap:</p>
<ol>
<li>Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</li>
<li>Less organized: when you put data on the heap, you request a certain amount of space. The OS finds an empty spot in the heap and returns a <code>pointer</code>.</li>
<li><code>Allocating</code>, while pushing values onto the stack is not considered allocating.</li>
<li>Slower because the OS must first find a big enough space and perform bookkeeping.</li>
<li>Accessing is slower because you have to follow a pointer.</li>
</ol>
<a class="post-dummy-target" id="ownership-rules"></a><h4>Ownership Rules</h4>
<ol>
<li>Each value in Rust has a variable that&rsquo;s called its <code>owner</code>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ol>
<a class="post-dummy-target" id="memory-and-allocation"></a><h4>Memory and Allocation</h4>
<p><strong><code>String</code> vs. <code>string literal</code></strong></p>
<p>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&rsquo;s immutability.</p>
<p><code>String</code> type is for supporting a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents.</p>
<p>When a variable goes out of scope, Rust calls a special function for us. This function is called <code>drop</code>.</p>
<p><strong>Move Ownership</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><figure><img src="/forgetful/svg/loading.min.svg" data-sizes="auto" data-src="/images/rust-move-ownership.svg" alt="" class="lazyload"></figure>
</p>
<p><code>s2 = s1</code> would move <code>s1</code> into <code>s2</code>. It&rsquo;s like a <code>shallow copy</code>. But it&rsquo;s a move because only <code>s2</code> is valid after the move. When <code>s2</code> goes out of scope, it alone will free the memory.</p>
<p><strong>NOTE: Rust will never automatically create &ldquo;deep&rdquo; copies of your data. Any automatic copying can be assumed to be inexpensive in terms of runtime performance.</strong></p>
<p><strong>Clone Data == Deep Copy</strong></p>
<p>Clone: copy the heap data of the <code>String</code> together with the stack data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">clone</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Copy Stack-Only Data</strong></p>
<p>Types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>x</code> is still valid after copy. It wasn&rsquo;t moved into <code>y</code>.</p>
<p><strong>Copy Trait and Drop Trait</strong></p>
<p>Rust has a special annotation called the <code>Copy</code> trait. If a type has the <code>Copy</code> trait, an older variable is still usable after assignment.</p>
<p><strong>NOTE: Rust won&rsquo;t let us annotate a type with the <code>Copy</code> trait if the type, or any of its parts, has implemented the <code>Drop</code> trait.</strong></p>
<p><strong>These Types are Copy</strong>
In general, any group of simple scalar values can be <code>Copy</code>, and nothing that requires allocation or is some form of resource is <code>Copy</code>.</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type.</li>
<li>All the floating point types.</li>
<li>The character type, <code>char</code>.</li>
<li>Tuples, if they only contain types that are also <code>Copy</code>. For example, (<code>i32</code>, <code>i32</code>) is <code>Copy</code>, but (<code>i32</code>, <code>String</code>) is not.</li>
</ul>
<a class="post-dummy-target" id="ownership-and-functions"></a><h4>Ownership and Functions</h4>
<p>Passing a variable to a function will <strong>move</strong> or <strong>copy</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// s comes into scope
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">takes_ownership</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="p">;</span><span class="w">             </span><span class="c1">// s&#39;s value moves into the function...
</span><span class="c1"></span><span class="w">                                    </span><span class="c1">// ... and so is no longer valid here
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">                      </span><span class="c1">// x comes into scope
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">makes_copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span class="w">                  </span><span class="c1">// x would move into the function,
</span><span class="c1"></span><span class="w">                                    </span><span class="c1">// but i32 is Copy, so it’s okay to still
</span><span class="c1"></span><span class="w">                                    </span><span class="c1">// use x afterward
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing
</span><span class="c1"></span><span class="w">  </span><span class="c1">// special happens.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_ownership</span><span class="p">(</span><span class="n">some_string</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// some_string comes into scope
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">some_string</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// Here, some_string goes out of scope and `drop` is called. The backing
</span><span class="c1"></span><span class="w">  </span><span class="c1">// memory is freed.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">makes_copy</span><span class="p">(</span><span class="n">some_integer</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// some_integer comes into scope
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">some_integer</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// Here, some_integer goes out of scope. Nothing special happens.
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="return-values-and-scope"></a><h4>Return Values and Scope</h4>
<p>Returning values can also transfer ownership.</p>
<a class="post-dummy-target" id="42-references-and-borrowing"></a><h3>4.2 References and Borrowing</h3>
<p><figure><img src="/forgetful/svg/loading.min.svg" data-sizes="auto" data-src="/images/rust-references.svg" alt="" class="lazyload"></figure>
</p>
<p><code>References</code> allow you to refer to some value without taking ownership of it. Because the variable is a reference and does not own the value, the value it points to will not be dropped when the reference goes out of scope.</p>
<a class="post-dummy-target" id="mutable-references"></a><h4>Mutable References</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">change</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// mut here
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">change</span><span class="p">(</span><span class="n">some_thing</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// and here
</span><span class="c1"></span><span class="w">    </span><span class="n">some_thing</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;, world&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Mutable references have one big restriction: <strong>you can have only one mutable reference to a particular piece of data in a particular scope</strong>.</p>
<p>This restriction can prevent data races at compile time. A <code>data race</code> is similar to a race condition and happens when these three behavior occur:</p>
<ul>
<li>Two or more pointers access the same data at the same time.</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>There&rsquo;s no mechanism being used to synchronize access to the data.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">  </span><span class="c1">// can&#39;t compile due to data race.
</span></code></pre></td></tr></table>
</div>
</div><p>But we can create a new scope to allow for multiple mutable references.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// r1 goes out of scope here, so we can make a new reference with no problems.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>A similar rule exists for combining mutable and immutable references.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// no problem
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// no problem
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// BIG PROBLEM, can&#39;t compile
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}, {}, and {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>But this can compile.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// no problem
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// no problem
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} and {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// r1 and r2 are no longer used after this point
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// no problem
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="43-the-slice-type"></a><h3>4.3 The Slice Type</h3>
<p>Another data type that does not have ownership is the <code>slice</code>.</p>
<a class="post-dummy-target" id="string-slices"></a><h4>String Slices</h4>
<p>A <code>string slice</code> is a reference to part of a <code>String</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">.</span><span class="p">.</span><span class="mi">5</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">.</span><span class="p">.</span><span class="mi">11</span><span class="p">]</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This is similar to taking a reference to the whole <code>String</code> but with the extra <code>[0..5]</code> bit.
<figure><img src="/forgetful/svg/loading.min.svg" data-sizes="auto" data-src="/images/rust-string-slice.svg" alt="" class="lazyload"></figure>
</p>
<p>The type that signifies <code>string slice</code> is written as <code>&amp;str</code>.</p>
<a class="post-dummy-target" id="string-literals-are-slices"></a><h4>String Literals Are Slices</h4>
<p>String literals are stored inside the binary.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Hello, world!&#34;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The type of <code>s</code> here is <code>&amp;str</code>: it’s a slice pointing to that specific point of the binary. This is also why string literals are immutable; <code>&amp;str</code> is an immutable reference.</p>
<a class="post-dummy-target" id="string-slices-as-parameters"></a><h4>String Slices as Parameters</h4>
<p>We&rsquo;ll write this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>not this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>If we have a string slice, we can pass that directly. If we have a <code>String</code>, we can pass a slice of the entire <code>String</code>. Defining a function to take a string slice instead of a reference to a <code>String</code> makes our API more general and useful without losing any functionality:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// first_word works on slices of `String`s
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_string</span><span class="p">[</span><span class="p">.</span><span class="p">.</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_string_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello world&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// first_word works on slices of string literals
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_string_literal</span><span class="p">[</span><span class="p">.</span><span class="p">.</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Because string literals *are* string slices already,
</span><span class="c1"></span><span class="w">    </span><span class="c1">// this works too, without the slice syntax!
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_word</span><span class="p">(</span><span class="n">my_string_literal</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="other-slices"></a><h4>Other Slices</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This slice has the type <code>&amp;[i32]</code>.</p>
<a class="post-dummy-target" id="the-concepts-of-ownership-borrowing-and-slices-ensure-memory-safety-in-rust-programs-at-compile-time"></a><h4>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time.</h4>
<a class="post-dummy-target" id="the-rust-language-gives-you-control-over-your-memory-usage-in-the-same-way-as-other-systems-programming-languages-but-having-the-owner-of-data-automatically-clean-up-that-data-when-the-owner-goes-out-of-scope-means-you-dont-have-to-write-and-debug-extra-code-to-get-this-control"></a><h4>The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.</h4>
<a class="post-dummy-target" id="chap-5-using-structs-to-structure-related-data"></a><h2>Chap 5 Using Structs to Structure Related Data</h2>
<a class="post-dummy-target" id="51-structs"></a><h3>5.1 Structs</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">username</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">sign_in_count</span>: <span class="kt">u64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">active</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">build_user</span><span class="p">(</span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">username</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">email</span><span class="p">,</span><span class="w">  </span><span class="c1">// shorthand of email: email because the name is exactly same
</span><span class="c1"></span><span class="w">        </span><span class="n">username</span><span class="p">,</span><span class="w">  </span><span class="c1">// same here
</span><span class="c1"></span><span class="w">        </span><span class="n">active</span>: <span class="nc">true</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">sign_in_count</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">user2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;another@example.com&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">username</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;anotherusername567&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="p">.</span><span class="n">user1</span><span class="w">  </span><span class="c1">// using user1&#39;s active and sign_in_count
</span><span class="c1"></span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Color</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// tuple struct
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="53-methods"></a><h3>5.3 Methods</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">width</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Method of Rectangle with &amp;self, which doesn&#39;t take ownership of self.
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rectangle</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&amp;</span><span class="o">&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="w"> </span><span class="n">height</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Associated function without self.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Invoke like `let sq = Rectangle::square(3);`
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">square</span><span class="p">(</span><span class="n">size</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">width</span>: <span class="nc">size</span><span class="p">,</span><span class="w"> </span><span class="n">height</span>: <span class="nc">size</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="6-enums"></a><h2>6 Enums</h2>
<p>Similar to <code>algebraic data types</code> in functional languages.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">IpAddrKind</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">V4</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">V6</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">four</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddrKind</span>::<span class="n">V4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// The enum inside another struct
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">IpAddr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">kind</span>: <span class="nc">IpAddrKind</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">address</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">home</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">kind</span>: <span class="nc">IpAddrKind</span>::<span class="n">V4</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">address</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">loopback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">kind</span>: <span class="nc">IpAddrKind</span>::<span class="n">V6</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">address</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;::1&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>A more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the <code>IpAddr</code> enum says that <strong>both <code>V4</code> and <code>V6</code> variants will have associated <code>String</code> values</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">IpAddr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">V4</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">  </span><span class="c1">// notice here
</span><span class="c1"></span><span class="w">    </span><span class="n">V6</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">  </span><span class="c1">// and here
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// No need for an extra struct.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">home</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">loopback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddr</span>::<span class="n">V6</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;::1&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Each variant can have different types and amounts of associated data. Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with a struct. Enums handle this case with ease:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">IpAddr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">V4</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">V6</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">home</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">loopback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddr</span>::<span class="n">V6</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;::1&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// This enum has four variants with different types.
</span><span class="c1"></span><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Quit</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span> <span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">ChangeColor</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// The following structs could hold the same data that the above enum variants hold.
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">QuitMessage</span><span class="p">;</span><span class="w">  </span><span class="c1">// unit struct
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">MoveMessage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">WriteMessage</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// tuple struct
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">ChangeColorMessage</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// tuple struct
</span></code></pre></td></tr></table>
</div>
</div><p>The benefit of defining an enum like <code>Message</code> is that it&rsquo;s possible for us to define a function to take any of these kinds of messages as we could with the <code>Message</code> enum.</p>
<p>We could also define methods on enums like what we do on structs using <code>impl</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Method defined on enum `Message`.
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Message</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// method body.
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">Write</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">m</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The <code>Option</code> enum is so useful that it&rsquo;s even included in the preclude; you don&rsquo;t need to bring it into scope explicitly. And you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix.</p>
<a class="post-dummy-target" id="62-the-match-control-flow-operator"></a><h3>6.2 The <code>match</code> Control Flow Operator</h3>
<p>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire <code>match</code> expression.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">value_in_cents</span><span class="p">(</span><span class="n">coin</span>: <span class="nc">Coin</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">coin</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Penny</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Lucky penny!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="mi">1</span><span class="w">  </span><span class="c1">// &lt;&lt;&lt; the expression
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Nickel</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Dime</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Quarter</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="patterns-that-bind-to-values"></a><h4>Patterns that Bind to Values</h4>
<p>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">derive(Debug)</span><span class="cp">]</span><span class="w"> </span><span class="c1">// so we can inspect the state in a minute
</span><span class="c1"></span><span class="k">enum</span> <span class="nc">UsState</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Alabama</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Alaska</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Coin</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Penny</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Nickel</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Dime</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Quarter</span><span class="p">(</span><span class="n">UsState</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">value_in_cents</span><span class="p">(</span><span class="n">coin</span>: <span class="nc">Coin</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">coin</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Penny</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Nickel</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Dime</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Coin</span>::<span class="n">Quarter</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// coin&#39;s value binds to `state`
</span><span class="c1"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;State quarter from {:?}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="mi">25</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Example of Option&lt;T&gt; binding
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">plus_one</span><span class="p">(</span><span class="n">x</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plus_one</span><span class="p">(</span><span class="n">five</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">none</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plus_one</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This pattern can be seen a lot in Rust code: <strong><code>match</code> against an enum, bind a variable to the data inside, and then execute code based on it.</strong></p>
<p><code>match</code> must cover every possible case. Matches in Rust are exhaustive.</p>
<a class="post-dummy-target" id="the-_-placeholder"></a><h4>The <code>_</code> Placeholder</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;one&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;five&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">7</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;seven&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w">  </span><span class="c1">// just do nothing for other possible values
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="63-concise-control-flow-with-if-let"></a><h3>6.3 Concise Control Flow with <code>if let</code></h3>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to handle values that match one patter while ignoring the rest.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">0</span><span class="k">u8</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Normal
</span><span class="c1"></span><span class="k">match</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Use `if let`
</span><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="err">`</span><span class="err">`</span><span class="err">`</span><span class="n">rust</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">coin</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Coin</span>::<span class="n">Quarter</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;State quarter from {:?}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Or use `if let`.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Coin</span>::<span class="n">Quarter</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coin</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;State quarter from {:?}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="7-managing-growing-projects-with-packages-crates-and-modules"></a><h2>7 Managing Growing Projects with Packages, Crates, and Modules</h2>
<p>A package can contain multiple binary crates and optionally one library crate.</p>
<ul>
<li>Packages</li>
<li>Crates</li>
<li>Modules and use</li>
<li>Paths</li>
</ul>
<a class="post-dummy-target" id="packages"></a><h3>Packages</h3>
<p>A package is one or more crates that provide a set of functionality. It:</p>
<ul>
<li>must contain at least one crate (either library or binary).</li>
<li>must contain zero or one library crates, and no more.</li>
<li>can contain as many binary crates as you&rsquo;d like.</li>
</ul>
<p>A package contains a <code>Cargo.toml</code> file that describes how to build those crates.</p>
<a class="post-dummy-target" id="crates"></a><h3>Crates</h3>
<p>A crate is a binary or library.</p>
<p>The <strong>crate root</strong> is a source file that Rust compiler starts from and makes up the root module of your crate. It could be <code>src/main.rs</code> or <code>src/lib.rs</code>.</p>
<p><code>src/main.rs</code> is the crate root of a binary crate with the same name as the package. While <code>src/lib.rs</code> is the crate root of a library crate.</p>
<p>A package can have multiple binary crates by placing files in the <code>src/bin</code> directory: each file will be a separate binary crate.</p>
<a class="post-dummy-target" id="modules"></a><h3>Modules</h3>
<p>Modules control the <strong>privacy</strong> of items.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// File: src/lib.rs
</span><span class="c1"></span><span class="k">mod</span> <span class="nn">front_of_house</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">mod</span> <span class="nn">hosting</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">seat_at_table</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">mod</span> <span class="nn">serving</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">take_order</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">serve_order</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">take_payment</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>src/main.rs</code> and <code>src/lib.rs</code> are called crate roots. The reason for their name is that the contents of either of these two files form a module named crate at the root of the crate’s module structure, known as the <code>module tree</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># Module Tree
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="paths"></a><h3>Paths</h3>
<p>A path is used to find an item in a module tree.</p>
<ul>
<li>An <strong>absolute path</strong> starts from a caret root by using a crate name or literal <code>crate</code>, for example, <code>crate::front_of_house::hosting::add_to_waitlist();</code></li>
<li>A <strong>relative path</strong> starts from the current module and uses <code>self</code>, <code>super</code> or an identifier in the current module. <code>super</code> is like <code>..</code> in filesystem navigation.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="nn">front_of_house</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">mod</span> <span class="nn">hosting</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// cannot compile when missing `pub` here
</span><span class="c1"></span><span class="w">    </span><span class="c1">// pub mod hosting {
</span><span class="c1"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">  </span><span class="c1">// cannot compile when missing `pub` here
</span><span class="c1"></span><span class="w">        </span><span class="c1">// pub fn add_to_waitlist() {}
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">eat_at_restaurant</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Absolute path
</span><span class="c1"></span><span class="w">    </span><span class="k">crate</span>::<span class="n">front_of_house</span>::<span class="n">hosting</span>::<span class="n">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Relative path
</span><span class="c1"></span><span class="w">    </span><span class="n">front_of_house</span>::<span class="n">hosting</span>::<span class="n">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Think it as `eat_at_restaurant` is in the same MODULE as `front_of_house`.
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="use-a-relative-or-absolute-path-our-preference-is-to-specify-absolute-paths-because-its-more-likely-to-move-code-definitions-and-item-calls-independently-of-each-other"></a><h4>Use a relative or absolute path? Our preference is to specify <code>absolute paths</code> because it’s more likely to move code definitions and item calls independently of each other.</h4>
<p>Modules define Rust&rsquo;s <strong>privacy boundary</strong>. If you want to make an item like a function or struct private, you put it in a module.</p>
<p>The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are <strong>private by default</strong>.</p>
<a class="post-dummy-target" id="items-in-a-parent-module-cant-use-the-private-items-inside-child-modules-but-items-in-child-modules-can-use-the-items-in-their-ancestor-modules"></a><h4>Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.</h4>
<a class="post-dummy-target" id="if-we-use-pub-before-a-struct-definition-we-make-the-struct-public-but-the-structs-fields-will-still-be-private"></a><h4>If we use <code>pub</code> before a struct definition, we make the struct public, but the struct&rsquo;s fields will still be private.</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="nn">back_of_house</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Breakfast</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="n">toast</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">seasonal_fruit</span>: <span class="nb">String</span><span class="p">,</span><span class="w">  </span><span class="c1">// private field
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Breakfast</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Because `seasonal_fruit` is private, we need a public associated
</span><span class="c1"></span><span class="w">        </span><span class="c1">// function to construct an instance of `Breakfast`. Or, we couldn&#39;t
</span><span class="c1"></span><span class="w">        </span><span class="c1">// create an instance of `Breakfast`.
</span><span class="c1"></span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">summer</span><span class="p">(</span><span class="n">toast</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Breakfast</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Breakfast</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">toast</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">toast</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">seasonal_fruit</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;peaches&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">eat_at_restaurant</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Order a breakfast in the summer with Rye toast
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">meal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">back_of_house</span>::<span class="n">Breakfast</span>::<span class="n">summer</span><span class="p">(</span><span class="s">&#34;Rye&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Change our mind about what bread we&#39;d like
</span><span class="c1"></span><span class="w">    </span><span class="n">meal</span><span class="p">.</span><span class="n">toast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Wheat&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;d like {} toast please&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">meal</span><span class="p">.</span><span class="n">toast</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// The next line won&#39;t compile if we uncomment it; we&#39;re not allowed
</span><span class="c1"></span><span class="w">    </span><span class="c1">// to see or modify the seasonal fruit that comes with the meal
</span><span class="c1"></span><span class="w">    </span><span class="c1">// meal.seasonal_fruit = String::from(&#34;blueberries&#34;);
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="in-contrast-if-we-make-an-enum-public-all-of-its-variants-are-then-public"></a><h4>In contrast, if we make an enum public, all of its variants are then public.</h4>
<a class="post-dummy-target" id="use-keyword"></a><h3><code>use</code> Keyword</h3>
<ul>
<li>Bring paths into scope.</li>
<li>Rename with <code>as</code> keyword. <code>use std::io::Result as IoResult;</code></li>
<li>Re-export names with <code>pub use</code>.</li>
<li>Use nested paths to clean up large <code>use</code> lists. <code>use std::{cmp::Ordering, io};</code></li>
<li>The glob operator. <code>use std::collections::*;</code>, use it carefully.</li>
</ul>
<a class="post-dummy-target" id="separating-modules-into-different-files"></a><h3>Separating Modules into Different Files</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// File: src/lib.rs
</span><span class="c1"></span><span class="c1">// `src/lib.rs` is still the crate root.
</span><span class="c1"></span><span class="k">mod</span> <span class="nn">front_of_house</span><span class="p">;</span><span class="w">  </span><span class="c1">// defined in file src/front_of_house.rs
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">front_of_house</span>::<span class="n">hosting</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">eat_at_restaurant</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">hosting</span>::<span class="n">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">hosting</span>::<span class="n">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">hosting</span>::<span class="n">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// File: src/front_of_house.rs
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">hosting</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// File: src/front_of_house/hosting.rs
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_to_waitlist</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="8-common-collections"></a><h2>8 Common Collections</h2>
<a class="post-dummy-target" id="vectors"></a><h3>Vectors</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">  </span><span class="c1">// vec! macro provided by Rust for convenience
</span></code></pre></td></tr></table>
</div>
</div><p>Two ways to access a value in a vector, either with indexing syntax or the <code>get</code> method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">third</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">;</span><span class="w">  </span><span class="c1">// cause the program to panic when it references a nonexistent element
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The third element is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// it gives us an `Option&lt;&amp;T&gt;`, will be `None` if the element doesn&#39;t exist
</span><span class="c1"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">third</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The third element is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;There is no third element.&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Get immutable references to each element.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">57</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Get mutable references to each element.
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span><span class="w">  </span><span class="c1">// `*` to dereference `i` to get to the value
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="using-an-enum-to-store-multiple-types"></a><h4>Using an Enum to Store Multiple Types</h4>
<p>Vectors can only store values that are the same type. We can define an enum whose variants will hold the different value types, and then all the enum variants will be considered the same type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">SpreadsheetCell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Int</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Float</span><span class="p">(</span><span class="kt">f64</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Text</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">SpreadsheetCell</span>::<span class="n">Int</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">SpreadsheetCell</span>::<span class="n">Text</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;blue&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">SpreadsheetCell</span>::<span class="n">Float</span><span class="p">(</span><span class="mf">10.12</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">]</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="strings"></a><h3>Strings</h3>
<p>Rust has only one string type in the core language, which is the string slice <code>str</code> that is usually seen in its borrowed form <code>&amp;str</code>.</p>
<p>The <code>String</code> type is provided by Rust&rsquo;s standard library.</p>
<p>Both <code>String</code> and string slices are UTF-8 encoded.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Create a String
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Or
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;initial contents&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Or
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;initial contents&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Update a String
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">s</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;l&#39;</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// add a single character
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// Or
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello, &#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;World!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Or
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">s4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="understand--operator"></a><h4>Understand <code>+</code> operator</h4>
<p>The <code>+</code> operator uses the <code>add</code> method with signature: <code>fn add(self, s: &amp;str) -&gt; String </code>.</p>
<p><code>s2</code> has an <code>&amp;</code>, meaning that we&rsquo;re adding a reference of the second string to the first one.</p>
<p>And <code>&amp;s2</code> is <code>&amp;String</code> but <code>+</code> accepts <code>&amp;str</code> for the second string. The compiler can coerce the <code>&amp;String</code> argument into a <code>&amp;str</code>. When we call the <code>add</code> method, Rust uses a <code>deref coercion</code>, which here turns <code>&amp;s2</code> into <code>&amp;s2[..]</code>.</p>
<p>The first parameter of <code>add</code> method is <code>self</code>, which means <code>s1</code> will take ownership of <code>self</code>, because <code>self</code> does not have an <code>&amp;</code>.</p>
<a class="post-dummy-target" id="indexing-into-strings"></a><h4>Indexing into Strings</h4>
<p>You can&rsquo;t access individual characters in a string by referencing them by index.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span><span class="w">  </span><span class="c1">// &lt;&lt;&lt; compile error
</span></code></pre></td></tr></table>
</div>
</div><p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hola&#34;</span><span class="p">)</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// 4, each letter takes 1 byte when encoded in UTF-8
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">)</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// 6, each Unicode scalar value takes 3 bytes when encoded in UTF-8
</span></code></pre></td></tr></table>
</div>
</div><p>Therefore, an index into the string&rsquo;s bytes will not always correlate to a valid Unicode scalar value. <code>你</code> is <code>\xe4\xbd\xa0</code> when encoded to UTF-8, if <code>&amp;&quot;你好&quot;[0]</code> returns the first byte <code>\xe4</code>, it is an unexpected value. So, Rust doesn&rsquo;t compile this code at all.</p>
<a class="post-dummy-target" id="bytes-and-scalar-values-and-grapheme-clusters"></a><h4>Bytes and Scalar Values and Grapheme Clusters</h4>
<p>Three relevant ways to look at strings from Rust&rsquo;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call <code>letters</code>).</p>
<p>Look at the Hindi word “नमस्ते” written in the Devanagari script, it is:</p>
<ul>
<li><strong>bytes</strong>: stored as a vector of u8 values that looks like this:
<code>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</code>.</li>
</ul>
<p><strong>That&rsquo;s 18 bytes and is how computers ultimately store this data.</strong></p>
<ul>
<li>
<p><strong>Unicode scalar</strong>: <code>['न', 'म', 'स', '्', 'त', 'े']</code>. The fourth and sixth are not letters.</p>
</li>
<li>
<p><strong>grapheme clusters</strong>: <code>[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</code>. What a person would call the four letters that make up the Hindi word.</p>
</li>
</ul>
<a class="post-dummy-target" id="slicing-strings"></a><h4>Slicing Strings</h4>
<p>Rust doesn&rsquo;t support using <code>[]</code> with a single number, but you can use <code>[]</code> with <strong>a range</strong> to create a string slice containing particular bytes.</p>
<p>What would happen if we used <code>&amp;hello[0..1]</code>? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector.</p>
<p>You should use ranges to create string slices with caution, because doing so can crash your program.</p>
<a class="post-dummy-target" id="methods-for-iterating-over-strings"></a><h4>Methods for Iterating Over Strings</h4>
<p>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the <code>chars</code> method. Calling <code>chars</code> on “नमस्ते” separates out and returns six values of type <code>char</code>. The <code>bytes</code> method returns each raw byte.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s">&#34;नमस्ते&#34;</span><span class="p">.</span><span class="n">chars</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s">&#34;नमस्ते&#34;</span><span class="p">.</span><span class="n">bytes</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="83-hash-maps"></a><h3>8.3 Hash Maps</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">  </span><span class="c1">// HashMap is not preclude
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">teams</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Blue&#34;</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Yellow&#34;</span><span class="p">)</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">initial_scores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">scores</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">teams</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">initial_scores</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">collect</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The type annotation <code>HashMap&lt;_, _&gt;</code> is needed here because it’s possible to collect into many different data structures and Rust doesn’t know which you want unless you specify.</p>
<p>For types that implement the <code>Copy</code> trait, like <code>i32</code>, the values are copied into the hash map. For owned values like <code>String</code>, the values will be moved and the hash map will be the owner of those values.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">field_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Favorite color&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">field_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Blue&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span><span class="w"> </span><span class="n">field_value</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// field_name and field_value are invalid at this point, try using them and
</span><span class="c1"></span><span class="c1">// see what compiler error you get!
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">scores</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Blue&#34;</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">scores</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Yellow&#34;</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">team_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Blue&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scores</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">team_name</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// Option&lt;&amp;V&gt;, could be `None`
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scores</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="only-inserting-a-value-if-the-key-has-no-value"></a><h4>Only Inserting a Value If the Key Has No Value</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">scores</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Blue&#34;</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// The return value of the `entry` method is an enum called `Entry`
</span><span class="c1"></span><span class="c1">// that represents a value that might or might not exist.
</span><span class="c1"></span><span class="c1">// The `or_insert` method on `Entry` is defined to return a mutable
</span><span class="c1"></span><span class="c1">// reference to the value for the corresponding `Entry` key if that
</span><span class="c1"></span><span class="c1">// key exists, and if not, inserts the parameter as the new value 
</span><span class="c1"></span><span class="c1">// for this key and returns a mutable reference to the new value. 
</span><span class="c1"></span><span class="n">scores</span><span class="p">.</span><span class="n">entry</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Yellow&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">or_insert</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">scores</span><span class="p">.</span><span class="n">entry</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Blue&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">or_insert</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">scores</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="updating-a-value-based-on-the-old-value"></a><h4>Updating a Value Based on the Old Value</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello world wonderful world&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">text</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">entry</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="p">.</span><span class="n">or_insert</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// count is mut reference
</span><span class="c1"></span><span class="w">    </span><span class="o">*</span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="9-error-handling"></a><h2>9 Error Handling</h2>
<a class="post-dummy-target" id="rust-has-no-exceptions"></a><h3>Rust has no exceptions.</h3>
<ul>
<li>Recoverable: such as a file not found error, it&rsquo;s reasonable to report the problem to the user and retry the operation.</li>
<li>Unrecoverable: symptoms of bugs.</li>
</ul>
<p><code>Result&lt;T, E&gt;</code> for recoverable errors and <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</p>
<a class="post-dummy-target" id="panic"></a><h3><code>panic!</code></h3>
<p>When the <code>panic!</code> macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.</p>
<a class="post-dummy-target" id="about-unwinding-the-stack"></a><h4>About unwinding the stack</h4>
<p>By default, when a panic occurs, the program starts <strong>unwinding</strong>, which means Rust walks back up the stack and cleans up the data from each function it encounters. But this walking back and cleanup is a lot of work. The alternative is to immediately <strong>abort</strong>, which ends the program without cleaning up. Memory that the program was using will then need to be cleaned up by the operating system.</p>
<a class="post-dummy-target" id="result"></a><h3><code>Result</code></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="how-do-we-know-a-methodfunction-returns-a-result"></a><h4>How do we know a method/function returns a <code>Result</code>?</h4>
<p>Take <code>File::open</code> as example, we could ask the compiler.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">f</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The compiler will tell you:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&#34;hello.txt&#34;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// `f` is `Ok` that contains a file handle if `open` succeeds,
</span><span class="c1"></span><span class="w">    </span><span class="c1">// otherwise, `f` is an instance of `Err` that contains more info
</span><span class="c1"></span><span class="w">    </span><span class="c1">// about the kind of error that happened.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Problem opening the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="matching-on-different-errors-using-errorkind"></a><h4>Matching on different errors using <code>error.kind()</code>.</h4>
<p>Error like <code>io::Error</code> has a method <code>kind</code> that we can call to ge an <code>io::ErrorKind</code> value. The enum <code>io::ErrorKind</code> has variants representing the different kinds of errors, i.e. <code>ErrorKind::NotFound</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">ErrorKind</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">kind</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">ErrorKind</span>::<span class="n">NotFound</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fc</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Problem creating the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">other_error</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Problem opening the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">other_error</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="shortcuts-for-panic-on-error-unwrap-and-expect"></a><h4>Shortcuts for panic on error: <code>unwrap</code> and <code>expect</code>.</h4>
<p>If the <code>Result</code> value is the <code>Ok</code> variant, <code>unwrap</code> will return the value inside the <code>Ok</code>. If the <code>Result</code> is the <code>Err</code> variant, <code>unwrap</code> will call the <code>panic!</code> macro for us.</p>
<p><code>expect</code> method is similar to <code>unwrap</code>, but providing good error messages can convey your intent.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Failed to open hello.txt&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="propagating-errors"></a><h4>Propagating Errors</h4>
<p>Give more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</p>
<p>The long version:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="-operator"></a><h4><code>?</code> Operator</h4>
<p>The short version of propagating errors:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// File::open(&#34;hello.txt&#34;)?.read_to_string(&amp;mut s)?;
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way as the <code>match</code> expressions.</p>
<a class="post-dummy-target" id="-can-only-be-used-in-functions-that-return-result"></a><h4><code>?</code> Can Only Be Used in Functions That Return <code>Result</code></h4>
<p>You cannot use it as the return value of <code>main()</code> as below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Can&#39;t compile due to `main()` returns `()`.
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Use this one:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The <code>Box&lt;dyn Error&gt;</code> type is called a trait object, meaning &ldquo;any kind of error&rdquo;.</p>
<a class="post-dummy-target" id="93-to-panic-or-not-to-panic"></a><h3>9.3 To <code>panic!</code> or Not to <code>panic!</code></h3>
<p>Returning <code>Result</code> is a good default choice when you&rsquo;re defining a function that might fail. Because the calling code could choose to attempt to recover, or it could decide that an <code>Err</code> value is unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an unrecoverable one.</p>
<p>In rare situations, it&rsquo;s more appropriate to write code that panics instead of returning a <code>Result</code>.</p>
<a class="post-dummy-target" id="use-unwrap-and-expect-to-panic-when-youre-writing-an-example-prototype-or-test-codes"></a><h4>Use <code>unwrap</code> and <code>expect</code> to panic when you&rsquo;re writing an example, prototype or test codes.</h4>
<a class="post-dummy-target" id="use-unwrap-and-expect-to-panic-when-youre-writing-codes-which-are-logically-impossible-to-fail"></a><h4>Use <code>unwrap</code> and <code>expect</code> to panic when you&rsquo;re writing codes which are logically impossible to fail.</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">IpAddr</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Hardcoded IP address&#39;s parse will not fail.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">home</span>: <span class="nc">IpAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="guidelines-for-error-handling"></a><h4>Guidelines for Error Handling</h4>
<p>It’s advisable to have your code <strong>panic</strong> when it’s possible that your code could end up in a <strong>bad state</strong>. In this context, a <strong>bad state</strong> is when some assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code—plus one or more of the following:</p>
<ul>
<li>The bad state is not something that’s expected to happen occasionally.</li>
<li>Your code after this point needs to rely on not being in this bad state.</li>
<li>There’s not a good way to encode this information in the types you use.</li>
</ul>
<a class="post-dummy-target" id="creating-custom-types-for-validation"></a><h4>Creating Custom Types for Validation</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">guess</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">continue</span><span class="w"></span><span class="nl"></span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// The code to validate guess could be repeated everywhere.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Define a `Guess` type to check the value is between 1 and 100
</span><span class="c1"></span><span class="w">    </span><span class="c1">// in its constructor.
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The secret number will be between 1 and 100.&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">continue</span><span class="w"></span><span class="nl"></span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secret_number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Guess value must be between 1 and 100, got {}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">value</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a <code>Guess</code> rather than an <code>i32</code> and wouldn&rsquo;t need to do any additional checks in its body.</p>
<a class="post-dummy-target" id="10-generic"></a><h2>10 Generic</h2>
<a class="post-dummy-target" id="101-generic-data-types"></a><h3>10.1 Generic Data Types</h3>
<a class="post-dummy-target" id="in-function-definitions"></a><h4>In Function Definitions</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="in-struct-definitions"></a><h4>In Struct Definitions</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="in-enum-definitions"></a><h4>In Enum Definitions</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="in-method-definitions"></a><h4>In Method Definitions</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">x</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>By declaring <code>T</code> as a generic type after <code>impl</code>, Rust can identify that the type in the angle brackets in <code>Point</code> is a generic type rather than a concrete type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// No `&lt;T&gt;` after `impl`.
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">distance_from_origin</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">powi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">powi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The method <code>distance_from_origin</code> is only on <code>Point&lt;f32&gt;</code> instances rather than on <code>Point&lt;T&gt;</code> instances with any generic type. It means the type <code>Point&lt;f32&gt;</code> will have that method and other instances of <code>Point&lt;T&gt;</code> where <code>T</code> is not of type <code>f32</code> will not have this method defined.</p>
<a class="post-dummy-target" id="performance-of-code-using-generics"></a><h4>Performance of Code Using Generics</h4>
<p><strong>Rust implements generics in such a way that your code doesn’t run any slower using generic types than it would with concrete types.</strong></p>
<p>Rust accomplishes this by performing <code>monomorphization</code> of the code that is using generics at compile time. <code>Monomorphization</code> is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.</p>
<p>The compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// i32
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// f64
</span></code></pre></td></tr></table>
</div>
</div><p>The monomorphized version of the code looks like the following. The generic <code>Option&lt;T&gt;</code> is replaced with the specific definitions created by the compiler:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Option_i32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Option_f64</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="kt">f64</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Option_i32</span>::<span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Option_f64</span>::<span class="nb">Some</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="102-traits-defining-shared-behavior"></a><h3>10.2 Traits: Defining Shared Behavior</h3>
<p><strong>Traits are similar to a feature often called interfaces in other languages, although with some differences.</strong></p>
<a class="post-dummy-target" id="defining-a-trait"></a><h4>Defining a Trait</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="implementing-a-trait-on-a-type"></a><h4>Implementing a Trait on a Type</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">headline</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">location</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">author</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">content</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}, by {} ({})&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">headline</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">author</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">location</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">username</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">content</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">reply</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">retweet</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">content</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="restrictions-with-trait-implementations"></a><h4>Restrictions with Trait Implementations</h4>
<p><strong>We can implement a trait on a type only if either the trait or the type is local to our crate.</strong>
For example, we can implement standard library traits like <code>Display</code> on a custom type like <code>Tweet</code>, and also implement <code>Summary</code> on <code>Vec&lt;T&gt;</code>.</p>
<p><strong>But we can’t implement external traits on external types.</strong>
For example, we can&rsquo;t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our crate, because <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library and aren&rsquo;t local to our crate.</p>
<a class="post-dummy-target" id="default-implementations"></a><h4>Default Implementations</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;(Read more...)&#34;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">  </span><span class="c1">// use the default implementation
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="traits-as-parameters"></a><h4>Traits as Parameters</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Breaking news! {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">summarize</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="trait-bound-syntax"></a><h4>Trait Bound Syntax</h4>
<p>The <code>impl Trait</code> syntax is actually syntax sugar for a longer form, which is called a <code>trait bound</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Breaking news! {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">summarize</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The trait bound syntax can express more complexity in other cases.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">
</span><span class="w"></span><span class="c1">// item1 and item2 could be different types as long as both types implement `Summary`.
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item1</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="p">,</span><span class="w"> </span><span class="n">item2</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// item1 and item2 must be the same type `T`.
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">item2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="specifying-multiple-trait-bounds-with-the--syntax"></a><h4>Specifying Multiple Trait Bounds with the <code>+</code> Syntax</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Can call `summarize` and use `{}` to format item here.
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Or
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Summary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Can call `summarize` and use `{}` to format item here.
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="clearer-trait-bounds-with-where-clauses"></a><h4>Clearer Trait Bounds with <code>where</code> Clauses</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Trait bounds is too long, making hard to read.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span>
    <span class="nc">where</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="w">  </span><span class="c1">// &lt;&lt;&lt; use where
</span><span class="c1"></span><span class="w">          </span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="returning-types-that-implement-traits"></a><h4>Returning Types that Implement Traits</h4>
<p>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">returns_summarizable</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">username</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;horse_ebooks&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">content</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;of course, as you probably already know, people&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">reply</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">retweet</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>However, you can only use <code>impl Trait</code> if you’re returning a single type. For example, this code that returns either a <code>NewsArticle</code> or a <code>Tweet</code> with the return type specified as <code>impl Summary</code> wouldn’t work:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">returns_summarizable</span><span class="p">(</span><span class="n">switch</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">switch</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="using-trait-bounds-to-conditionally-implement-methods"></a><h4>Using Trait Bounds to Conditionally Implement Methods</h4>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters, we can <strong>implement methods conditionally for types that implement the specified traits</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Display</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// All `Pair&lt;T&gt;` always implements the `new` function.
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// But only the type `T` which implements `Display` and `PartialOrd` implements `cmp_display`.
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp_display</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The largest member is x = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The largest member is y = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Implement a trait for any type that implements another trait.</strong></p>
<p>Implementations of a trait on any type that satisfies the trait bounds are called <code>blanket implementations</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>In <strong>dynamically typed languages</strong>, we would get an error at <strong>runtime</strong> if we called a method on a type that the type didn’t implement. But Rust moves these errors to <strong>compile time</strong> so we’re forced to fix the problems before our code is even able to run. Additionally, we don’t have to write code that <strong>checks</strong> for behavior at runtime because we’ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</p>
<a class="post-dummy-target" id="103-validating-references-with-lifetimes"></a><h3>10.3 Validating References with Lifetimes</h3>
<a class="post-dummy-target" id="the-borrow-checker"></a><h4>The Borrow Checker</h4>
<p>The borrow checker compares scopes to determine whether all borrows are valid.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">                </span><span class="c1">// ---------+-- &#39;a
</span><span class="c1"></span><span class="w">                          </span><span class="c1">//          |
</span><span class="c1"></span><span class="w">    </span><span class="p">{</span><span class="w">                     </span><span class="c1">//          |
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">        </span><span class="c1">// -+-- &#39;b  |
</span><span class="c1"></span><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">           </span><span class="c1">//  |       |
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">                     </span><span class="c1">// -+       |
</span><span class="c1"></span><span class="w">                          </span><span class="c1">//          |
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;r: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="p">;</span><span class="w"> </span><span class="c1">//          |
</span><span class="c1"></span><span class="p">}</span><span class="w">                         </span><span class="c1">// ---------+
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="generic-lifetimes-in-functions"></a><h4>Generic Lifetimes in Functions</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;abcd&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;xyz&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longest</span><span class="p">(</span><span class="n">string1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">string2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The longest string is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Can&#39;t compile
</span><span class="c1"></span><span class="c1">// The compiler(borrow checker) can&#39;t guarantee the reference `longest`
</span><span class="c1"></span><span class="c1">// returned will be still valid in scope. The compiler can&#39;t tell whether
</span><span class="c1"></span><span class="c1">// the reference being returned refers to `x` or `y`, what if it refers to
</span><span class="c1"></span><span class="c1">// `x`, but `x` is out of scope when the caller uses the returned reference.
</span><span class="c1"></span><span class="c1">// For example,
</span><span class="c1"></span><span class="c1">// let string1 = String::from(&#34;xyz&#34;);
</span><span class="c1"></span><span class="c1">// let result;
</span><span class="c1"></span><span class="c1">// {
</span><span class="c1"></span><span class="c1">//     let string2 = String::from(&#34;long string is long&#34;);
</span><span class="c1"></span><span class="c1">//     result = longest(string1.as_str(), string2.as_str());
</span><span class="c1"></span><span class="c1">// }
</span><span class="c1"></span><span class="c1">// println!(&#34;The longest string is {}&#34;, result);
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">x</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">y</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:33
  |
1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function&#39;s return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="lifetime-annotation-syntax"></a><h4>Lifetime Annotation Syntax</h4>
<p><strong>1. Only works on references.</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">&amp;</span><span class="kt">i32</span><span class="w">        </span><span class="c1">// a reference
</span><span class="c1"></span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="w">     </span><span class="c1">// a reference with an explicit lifetime
</span><span class="c1"></span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="c1">// a mutable reference with an explicit lifetime
</span></code></pre></td></tr></table>
</div>
</div><p><strong>2. Not change how long any of the references live.</strong></p>
<p><strong>3. Not has much meaning for one lifetime annotation.</strong>
The annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. For example, let’s say we have a function with the parameter first that is a reference to an <code>i32</code> with lifetime <code>'a</code>. The function also has another parameter named second that is another reference to an <code>i32</code> that also has the lifetime <code>'a</code>. The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.</p>
<a class="post-dummy-target" id="lifetime-annotations-in-function-signatures"></a><h4>Lifetime Annotations in Function Signatures</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">x</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">y</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The function signature now tells Rust that both parameters, <code>x</code> and <code>y</code>, are string slices that live at least as long as lifetime <code>'a</code>. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime <code>'a</code>.</p>
<p><strong>Remember</strong>, when we specify the <strong>lifetime parameters</strong> in this function signature, we’re <strong>not changing the lifetimes</strong> of any values passed in or returned. Rather, we’re specifying that the <strong>borrow checker</strong> should <strong>reject</strong> any values that <strong>don’t adhere to these constraints</strong>.</p>
<p>When we pass concrete references to <code>longest</code>, the generic lifetime <code>'a</code> will get the concrete lifetime that is equal to the <strong>smaller</strong> of the lifetimes of <code>x</code> and <code>y</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Can&#39;t compile.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;long string is long&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">string2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;xyz&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longest</span><span class="p">(</span><span class="n">string1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">string2</span><span class="p">.</span><span class="n">as_str</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The longest string is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>As humans, we can look at this code and see that <code>string1</code> is longer than <code>string2</code> and therefore result will contain a reference to <code>string1</code>. Because <code>string1</code> has not gone out of scope yet, a reference to <code>string1</code> will still be valid for the <code>println!</code> statement.</p>
<p>However, <strong>the compiler can’t see that the reference</strong> is valid in this case. <strong>We’ve told Rust</strong> that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the references passed in. Therefore, the <strong>borrow checker disallows</strong> the above code as possibly having an invalid reference.</p>
<a class="post-dummy-target" id="lifetime-annotations-in-struct-definitions"></a><h4>Lifetime Annotations in Struct Definitions</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">ImportantExcerpt</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">part</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">novel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Call me Ishmael. Some years ago...&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first_sentence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">novel</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Could not find a &#39;.&#39;&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImportantExcerpt</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">part</span>: <span class="nc">first_sentence</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The generic lifetime annotation means an instance of <code>ImportantExcerpt</code> can’t outlive the reference it holds in its <code>part</code> field.</p>
<a class="post-dummy-target" id="lifetime-elision"></a><h4>Lifetime Elision</h4>
<p>You need to specify lifetime parameters for functions or structs that use references. But as the compiler (borrow checker) becoming smarter, it can infer the lifetimes in some patterns and wouldn&rsquo;t need explicit annotations.</p>
<p>The patterns programmed into Rust&rsquo;s analysis of references are called the <code>lifetime elision rules</code>. The compiler uses three rules to figure out what lifetimes references have when there aren’t explicit annotations. If the compiler gets to the end of the three rules and there are still references for which it can’t figure out lifetimes, the compiler will stop with an error. These rules apply to <code>fn</code> definitions as well as <code>impl</code> blocks.</p>
<ul>
<li>Rule #1: each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32);</code> a function with two parameters gets two separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32);</code> and so on.</li>
<li>Rule #2: if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</li>
<li>Rule #3: if there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</li>
</ul>
<p>Examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="c1">// After applying Rule #1: fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;str {
</span><span class="c1"></span><span class="c1">// After applying Rule #2: fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;&#39;a str {
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">enumerate</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="sc">b&#39; &#39;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">.</span><span class="p">.</span><span class="n">i</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="p">.</span><span class="p">.</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Can&#39;t compile.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="c1">// After applying Rule #1: fn longest(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;str {
</span><span class="c1"></span><span class="c1">// Rule #2 doesn&#39;t apply.
</span><span class="c1"></span><span class="c1">// Rule #3 doesn&#39;t apply either.
</span><span class="c1"></span><span class="c1">// The compiler worked through all lifetime elision rules but still couldn&#39;t
</span><span class="c1"></span><span class="c1">// figure out all the lifetimes of the references in the signature.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="the-static-lifetime"></a><h4>The Static Lifetime</h4>
<p>One special lifetime we need to discuss is <code>'static</code>, which means that this reference can <strong>live for the entire duration of the program</strong>. All string literals have the <code>'static</code> lifetime, which we can annotate as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;I have a static lifetime.&#34;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="11-writing-automated-tests"></a><h2>11 Writing Automated Tests</h2>
<a class="post-dummy-target" id="111-how-to-write-tests"></a><h3>11.1 How to Write Tests</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">test_case</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed.</p>
<a class="post-dummy-target" id="adding-custom-failure-messages"></a><h4>Adding Custom Failure Messages</h4>
<p>Any arguments specified after the one required argument to <code>assert!</code> or the two required arguments to <code>assert_eq!</code> and <code>assert_ne!</code> are passed along to the <code>format!</code> macro, so you can pass a format string that contains <code>{}</code> placeholders and values to go in those placeholders.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">&#34;Carol&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="s">&#34;Greeting did not contain name, value was `{}`&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="checking-for-panics-with-should_panic"></a><h4>Checking for Panics with <code>should_panic</code></h4>
<p>It’s also important to check that our code handles error conditions as we expect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Guess value must be between 1 and 100, got {}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">value</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">cfg(test)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="cp">#[</span><span class="cp">should_panic</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// should_panic attribute accepts `expected` parameter to make the test
</span><span class="c1"></span><span class="w">    </span><span class="c1">// more precise.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// #[should_panic(expected = &#34;Guess value must be less than or equal to 100&#34;)]
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">greater_than_100</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Guess</span>::<span class="n">new</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="using-resultt-e-in-tests"></a><h4>Using <code>Result&lt;T, E&gt;</code> in Tests</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">cfg(test)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;two plus two does not equal four&#34;</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="112-controlling-how-tests-are-run"></a><h3>11.2 Controlling How Tests Are Run</h3>
<a class="post-dummy-target" id="running-a-subset-of-tests-by-name"></a><h4>Running a Subset of Tests by Name</h4>
<p>You can choose which tests to run by passing <code>cargo test</code> the name or names of the test(s) you want to run as an argument.</p>
<p>We can specify part of a test name, and any test whose name matches that value will be run.</p>
<a class="post-dummy-target" id="ignoring-some-tests-unless-specifically-requested"></a><h4>Ignoring Some Tests Unless Specifically Requested</h4>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. <code>cargo test -- --ignored</code> to run only the ignored tests.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">ignore</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">expensive_test</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// code that takes an hour to run
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="113-test-organization"></a><h3>11.3 Test Organization</h3>
<p>The Rust community thinks about tests in terms of two main categories: <code>unit tests</code> and <code>integration tests</code>.</p>
<a class="post-dummy-target" id="ut---testing-one-module-in-isolation-at-a-time-and-can-test-private-interfaces"></a><h4>UT - testing one module in isolation at a time, and can test private interfaces.</h4>
<a class="post-dummy-target" id="it---entirely-external-to-your-library-and-use-your-code-in-the-same-way-any-other-external-code-would-using-only-the-public-interface-and-potentially-exercising-multiple-modules-per-test"></a><h4>IT - entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</h4>
<a class="post-dummy-target" id="unit-tests"></a><h4>Unit Tests</h4>
<p>You’ll put unit tests in the <code>src</code> directory in each file with the code that they’re testing. The convention is to create a module named <code>tests</code> in each file to contain the test functions and to annotate the module with <code>cfg(test)</code>.</p>
<a class="post-dummy-target" id="the-tests-module-and-cfgtest"></a><h4>The Tests Module and <code>#[cfg(test)]</code></h4>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run the test code only when you run <code>cargo test</code>, not when you run <code>cargo build</code>. This <strong>saves compile time</strong> when you only want to build the library and <strong>saves space</strong> in the resulting compiled artifact because the tests are not included. You’ll see that because integration tests go in a different directory, they don’t need the <code>#[cfg(test)]</code> annotation. However, because unit tests go in the same files as the code, you’ll use <code>#[cfg(test)]</code> to <strong>specify that they shouldn’t be included in the compiled result</strong>.</p>
<a class="post-dummy-target" id="integration-tests"></a><h4>Integration Tests</h4>
<p>To create integration tests, <strong>you first need a <code>tests</code> directory</strong>.</p>
<p>We create a <code>tests</code> directory at the top level of our project directory, next to <code>src</code>. Cargo knows to look for integration test files in this directory.</p>
<p>To avoid having <code>common</code> appear in the test output, instead of creating <code>tests/common.rs</code>, we’ll create <code>tests/common/mod.rs</code>.</p>
<a class="post-dummy-target" id="integration-tests-for-binary-crates"></a><h4>Integration Tests for Binary Crates</h4>
<p>If our project is a binary crate that <strong>only</strong> contains a <code>src/main.rs</code> file and <strong>doesn’t</strong> have a <code>src/lib.rs</code> file, we <strong>can’t</strong> create integration tests in the <code>tests</code> directory and bring functions defined in the <code>src/main.rs</code> file into scope with a <code>use</code> statement. Only library crates expose functions that other crates can <code>use</code>; binary crates are meant to be run on their own.</p>
<p>This is one of the reasons Rust projects that provide a binary <strong>have a straightforward <code>src/main.rs</code> file that calls logic that lives in the <code>src/lib.rs</code> file</strong>. Using that structure, integration tests can test the library crate with use to make the important functionality available. If the important functionality works, the small amount of code in the <code>src/main.rs</code> file will work as well, and that small amount of code doesn’t need to be tested.o</p>
<a class="post-dummy-target" id="12-an-io-project-building-a-command-line-program"></a><h2>12 An I/O Project: Building a Command Line Program</h2>
<a class="post-dummy-target" id="123-refactoring-to-improve-modularity-and-error-handling"></a><h3>12.3 Refactoring to Improve Modularity and Error Handling</h3>
<a class="post-dummy-target" id="guideline-for-splitting-the-separate-concerns-of-a-binary-program-when-main-starts-getting-large"></a><h4>Guideline for splitting the separate concerns of a binary program when main starts getting large.</h4>
<p>The process:</p>
<ul>
<li>Split your program into a <code>main.rs</code> and a <code>lib.rs</code> and move your program’s logic to <code>lib.rs</code>.</li>
<li>As long as your command line parsing logic is small, it can remain in <code>main.rs</code>.</li>
<li>When the command line parsing logic starts getting complicated, extract it from <code>main.rs</code> and move it to <code>lib.rs</code>.</li>
</ul>
<p><code>main</code> function should be limited to the following:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <code>lib.rs</code></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
<p>Because you can’t test the <code>main</code> function directly, this structure lets you test all of your program’s logic by moving it into functions in <code>lib.rs</code>. The only code that remains in <code>main.rs</code> will be small enough to verify its correctness by reading it.</p>
<a class="post-dummy-target" id="13-functional-language-features-iterators-and-closures"></a><h2>13 Functional Language Features: Iterators and Closures</h2>
<p>Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.</p>
<a class="post-dummy-target" id="131-closures-anonymous-functions-that-can-capture-their-environment"></a><h3>13.1 Closures: Anonymous Functions that Can Capture Their Environment</h3>
<p>You can create the closure in one place and then call the closure to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they&rsquo;re defined.</p>
<a class="post-dummy-target" id="closure-type-inference-and-annotation"></a><h4>Closure Type Inference and Annotation</h4>
<p><strong>Closures don’t require you to annotate the types</strong> of the parameters or the return value like fn functions do. Type annotations are <strong>required on functions</strong> because they’re part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. But closures aren’t used in an exposed interface like this: they’re <strong>stored in variables and used without naming them and exposing them</strong> to users of our library.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span>  <span class="nf">add_one_v1</span><span class="w">   </span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">// function
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">add_one_v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span>: <span class="kt">u32</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">  </span><span class="c1">// fully annotated closure
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">add_one_v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">  
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">add_one_v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w">               </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="p">;</span><span class="w">  </span><span class="c1">// only one expression in body
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Closure definitions will have one concrete type inferred for each of their parameters and for their return value.</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// can&#39;t compile
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">example_closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_closure</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_closure</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those types are then locked in to the closure in <code>example_closure</code>, and we get a type error if we try to use a different type with the same closure.</p>
<a class="post-dummy-target" id="storing-closures-using-generic-parameters-and-the-fn-traits"></a><h4>Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</h4>
<p>We can create a <strong>struct</strong> that will hold the closure and the resulting value of calling the closure. The struct will <strong>execute</strong> the closure <strong>only if we need</strong> the resulting value, and it will <strong>cache the resulting value</strong> so the rest of our code doesn’t have to be responsible for saving and reusing the result. You may know this pattern as <code>memoization</code> or <code>lazy evaluation</code>.</p>
<p>Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different.</p>
<p>All closures implement at least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Fn</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span>
<span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">calculation</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">value</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Fn</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span>
<span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">calculation</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Cacher</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">calculation</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">value</span>: <span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">calculation</span><span class="p">)</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">v</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Note:</strong> <strong>Functions</strong> can implement all three of the <code>Fn</code> traits too. If what we want to do <strong>doesn’t require capturing</strong> a value from the environment, we can use a function rather than a closure where we need something that implements an <code>Fn</code> trait.</p>
<a class="post-dummy-target" id="capturing-the-environment-with-closures"></a><h4>Capturing the Environment with Closures</h4>
<p>Closures have an additional capability that functions don’t have: <strong>they can capture their environment and access variables from the scope in which they’re defined</strong>.</p>
<p>Closures can capture values from their environment in <strong>three</strong> ways, which directly map to the three ways a function can take a parameter: <strong>taking ownership, borrowing mutably, and borrowing immutably.</strong> These are encoded in the three <code>Fn</code> traits as follows:</p>
<p><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known as the closure’s environment. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The Once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.
<code>FnMut</code> can change the environment because it mutably borrows values.
<code>Fn</code> borrows values from the environment immutably.
When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">equal_to_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">z</span><span class="o">|</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">equal_to_x</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>In this example, the <code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait) because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to <code>move</code> the data so it’s owned by the new thread.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">equal_to_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">z</span><span class="o">|</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Can&#39;t compile due to `x` was moved to closure `equal_to_x` already,
</span><span class="c1"></span><span class="w">    </span><span class="c1">// `main` has no ownershipt of `x` here.
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;can&#39;t use x here: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">equal_to_x</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based on what happens in the closure body.</strong></p>
<p>Because <code>Fn</code> clousres have minimum influence to its enclosing scope, it just borrows variables immutably.</p>
<a class="post-dummy-target" id="132-processing-a-series-of-items-with-iterators"></a><h3>13.2 Processing a Series of Items with Iterators</h3>
<p><code>Iterator</code> trait definition:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// methods with default implementations elided
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Notice this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code>, which are defining an <code>associated type</code> with this trait. That is, implementing the <code>Iterator</code> trait requires that you also define an <code>Item</code> type, and this <code>Item</code> type is used in the return type of the next method. In other words, the <code>Item</code> type will be the type returned from the iterator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">iterator_demonstration</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v1_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">3</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. <strong>We didn’t need to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took ownership of <code>v1_iter</code> and made it mutable behind the scenes.</strong></p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable references to the values in the vector. The <code>iter</code> method produces an iterator over <strong>immutable references</strong>. If we want to create an iterator that takes ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code>. Similarly, if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v1_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">into_iter</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Can&#39;t compile due to v1 moved into into_iter.
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="methods-that-consume-the-iterator"></a><h4>Methods that Consume the Iterator</h4>
<p>Methods that call <code>next</code> are called <strong>consuming adaptors</strong>, because calling them uses up the iterator.</p>
<a class="post-dummy-target" id="methods-that-produce-other-iterators"></a><h4>Methods that Produce Other Iterators</h4>
<p>Other methods defined on the <code>Iterator</code> trait, known as <strong>iterator adaptors</strong>, allow you to change iterators into different kinds of iterators.</p>
<p><code>map</code> is an iterator adaptor.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v1</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">v2</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="p">.</span><span class="n">collect</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="creating-our-own-iterators-with-the-iterator-trait"></a><h4>Creating Our Own Iterators with the <code>Iterator</code> Trait</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Counter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">count</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Counter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">count</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="using-other-iterator-trait-methods"></a><h4>Using Other <code>Iterator</code> Trait Methods</h4>
<p>We implemented the <code>Iterator</code> trait by defining the <code>next</code> method, so we can now use any <code>Iterator</code> trait <strong>method’s default implementations as defined in the standard library</strong>, because they all use the <code>next</code> method’s functionality.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">using_other_iterator_trait_methods</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">Counter</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">Counter</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                                 </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                                 </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                                 </span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>You can use iterators and closures without fear! They make code seem like it’s higher level but don’t impose a runtime performance penalty for doing so.</strong></p>
<a class="post-dummy-target" id="14-cargo-and-cratesio"></a><h2>14 Cargo and Crates.io</h2>
<a class="post-dummy-target" id="142-publishing-a-crate-to-cratesio"></a><h3>14.2 Publishing a Crate to Crates.io</h3>
<a class="post-dummy-target" id="making-useful-documentation-comments"></a><h4>Making Useful Documentation Comments</h4>
<ol>
<li>Use three slashes, <code>///</code>.</li>
<li>Support Markdown notation.</li>
<li>Commonly used setions: <code>Examples</code>, <code>Panics</code>, <code>Errors</code>, and <code>Safety</code>.</li>
<li>Run <code>cargo test</code> will run the code examples.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">/// Adds one to the number given.
</span><span class="sd"></span><span class="sd">///
</span><span class="sd"></span><span class="sd">/// # Examples
</span><span class="sd"></span><span class="sd">///
</span><span class="sd"></span><span class="sd">/// ```
</span><span class="sd"></span><span class="sd">/// let arg = 5;
</span><span class="sd"></span><span class="sd">/// let answer = my_crate::add_one(arg);
</span><span class="sd"></span><span class="sd">///
</span><span class="sd"></span><span class="sd">/// assert_eq!(6, answer);
</span><span class="sd"></span><span class="sd">/// ```
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="commenting-contained-items"></a><h4>Commenting Contained Items</h4>
<p><code>//!</code> adds documentation to the item that contains the comments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">//! # My Crate
</span><span class="sd"></span><span class="sd">//!
</span><span class="sd"></span><span class="sd">//! `my_crate` is a collection of utilities to make performing certain
</span><span class="sd"></span><span class="sd">//! calculations more convenient.
</span><span class="sd"></span><span class="w">
</span><span class="w"></span><span class="sd">/// Adds one to the number given.
</span><span class="sd"></span><span class="c1">// --snip--
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="exporting-a-convenient-public-api-with-pub-use"></a><h4>Exporting a Convenient Public API with <code>pub use</code></h4>
<p>Some structs may be deep in the hierarchy of your crate, which is not freindly to the user who wants to use it.</p>
<p>Could use <code>pub use</code> to re-export your types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="sd">//! # Art
</span><span class="sd"></span><span class="sd">//!
</span><span class="sd"></span><span class="sd">//! A library for modeling artistic concepts.
</span><span class="sd"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="bp">self</span>::<span class="n">kinds</span>::<span class="n">PrimaryColor</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="bp">self</span>::<span class="n">kinds</span>::<span class="n">SecondaryColor</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="bp">self</span>::<span class="n">utils</span>::<span class="n">mix</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">kinds</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">utils</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// In others crate.
</span><span class="c1"></span><span class="k">use</span><span class="w"> </span><span class="n">art</span>::<span class="n">PrimaryColor</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">art</span>::<span class="n">mix</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="145-extending-cargo-with-custom-commands"></a><h3>14.5 Extending Cargo with Custom Commands</h3>
<p>Cargo is designed so you can extend it with new subcommands without having to modify Cargo. If a binary in your <code>$PATH</code> is named <code>cargo-something</code>, you can run it as if it was a Cargo subcommand by running <code>cargo something</code>. Custom commands like this are also listed when you run <code>cargo --list</code>.</p>
<a class="post-dummy-target" id="15-smart-pointers"></a><h2>15 Smart Pointers</h2>
<p>A <code>pointer</code> is a general concept for a variable that contains an address in memory. This address refers to, or &ldquo;points at&rdquo;, some other data.</p>
<p>References are a kind of pointer, without any special capabilities other than referring to data. Also, they don&rsquo;t have any overhead.</p>
<p><code>Smart pointers</code>, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities.</p>
<p>In Rust, the different smart pointers defined in the standard library provide <strong>functionality</strong> beyond that provided by references. For example, the <code>reference counting</code> smart pointer type enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.</p>
<p>An additional difference between references and smart pointers is that <strong>references</strong> are pointers that <strong>only borrow</strong> data; in contrast, in many cases, <strong>smart pointers</strong> <strong>own</strong> the data they point to. <code>String</code> and <code>Vec&lt;T&gt;</code> are counted as smart pointers because they own some memory and allow you to manipulate it.</p>
<p>Smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.</p>
<ul>
<li><code>Deref</code> allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers.</li>
<li><code>Drop</code> allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>
</ul>
<a class="post-dummy-target" id="151-using-boxt-to-point-to-data-on-the-heap"></a><h3>15.1 Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap</h3>
<p>Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data.</p>
<p>Boxed don&rsquo;t have performance overhead, other than storing their data on the heap instead of on the stack. But they don&rsquo;t have many extra capabilities either.</p>
<p>You&rsquo;ll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can&rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size.</li>
<li>When you have a large amount of data and you want to transfer ownership but ensure the data won&rsquo;t be copied when you do so.</li>
</ul>
<p><strong>Transferring ownership</strong> of a large amount of data can take a long time because the data is <strong>copied around on the stack</strong>. To improve performance in this situation, we can store the large amount of <strong>data on the heap in a box</strong>. Then, only the small amount of <strong>pointer</strong> data is <strong>copied</strong> around on the <strong>stack</strong>, while the data it references stays in one place on the heap.</p>
<ul>
<li>When you want to own a value and you care only that it&rsquo;s a type that implements a particular trait rather than being of a specific type. <code>Trait objects</code> do what as you want.</li>
</ul>
<a class="post-dummy-target" id="using-a-boxt-to-store-data-on-the-heap"></a><h4>Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// store an `i32` value on the heap
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;b = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// we can access the data in the box similar to
</span><span class="c1"></span><span class="w">                            </span><span class="c1">// how we would if this data were on the stack
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>When a box (<code>b</code> above) goes out of scope, the deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</strong></p>
<a class="post-dummy-target" id="enabling-recursive-types-with-boxes"></a><h4>Enabling Recursive Types with Boxes</h4>
<p>At compile time, Rust needs to know how much space a type takes up. One type whose size can’t be known at compile time is a <code>recursive type</code>, where a value can have as part of itself another value of the same type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Cons</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Nil</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">List</span>::<span class="p">{</span><span class="n">Cons</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">// Can&#39;t compile because Rust can&#39;t figure out how much space it needs to
</span><span class="c1"></span><span class="c1">// store a `List` value.
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Quit</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span> <span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">ChangeColor</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>To determine how much space to allocate for a <code>Message</code> value, Rust goes through each of the variants to see <strong>which variant needs the most space</strong>. Rust sees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough space to store two <code>i32</code> values, and so forth. Because only one variant will be used, the most space a <code>Message</code> value will need is the space it would take to store the largest of its variants.</p>
<p><code>List</code> enum above causes infinite calculation of space.
<figure><img src="/forgetful/svg/loading.min.svg" data-sizes="auto" data-src="/images/rust-infinite-cons-variants.svg" alt="" class="lazyload"></figure>
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Cons</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">)</span><span class="p">,</span><span class="w">  </span><span class="c1">// use Box now
</span><span class="c1"></span><span class="w">    </span><span class="n">Nil</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">List</span>::<span class="p">{</span><span class="n">Cons</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Nil</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>A <code>Box&lt;T&gt;</code> needs a pointer’s size doesn’t change based on the amount of data it’s pointing to.</p>
<p>The <code>Cons</code> variant will need the size of an <code>i32</code> plus the space to store the box’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space than the <code>Cons</code> variant. We now know that any <code>List</code> value will take up the size of an <code>i32</code> plus the size of a box’s pointer data.</p>
<p>Boxes provide only the indirection and heap allocation; they don’t have any other special capabilities. They also don’t have any performance overhead that these special capabilities incur, so they can be <strong>useful</strong> in cases like the cons list where the <strong>indirection is the only feature we need</strong>.</p>
<a class="post-dummy-target" id="152-treating-smart-pointers-like-regular-references-with-the-deref-trait"></a><h3>15.2 Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</h3>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the <code>dereference operator</code>, <code>*</code>. By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>
<a class="post-dummy-target" id="defining-our-own-smart-pointer"></a><h4>Defining Our Own Smart Pointer</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">MyBox</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"></a><h4>Treating a Type Like a Reference by Implementing the Deref Trait</h4>
<p>The <code>Deref</code> trait, provided by the standard library, requires us to implement one method named <code>deref</code> that <strong>borrows</strong> <code>self</code> and <strong>returns a reference to the inner data</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Defines an associated type for the Deref trait to use.
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references, like <code>let y = &amp;x;</code>, the compiler can only dereference this <code>y</code>.</p>
<p>The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that it knows how to dereference.</p>
<p>For example, <code>let y = MyBox::new(x);</code>. When we entered <code>*y</code>, Rust actually ran this code: <code>*(y.deref())</code>. <code>y.deref()</code> returned a reference to <code>x</code>, then the plain dereference <code>*</code> outside followed the reference to the data.</p>
<a class="post-dummy-target" id="implicit-deref-coercions-with-functions-and-methods"></a><h4>Implicit Deref Coercions with Functions and Methods</h4>
<p><code>Deref Coercion</code> is a convenience that Rust performs on <strong>arguments</strong> to <strong>functions</strong> and <strong>methods</strong>.</p>
<p>The deref coercion feature also lets us write more code that can work for either references or smart pointers.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hello, {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Rust&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Same as
</span><span class="c1"></span><span class="w">    </span><span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="p">[</span><span class="p">.</span><span class="p">.</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Calling the <code>hello</code> function with <code>&amp;m</code>, which is a reference to a <code>MyBox&lt;String&gt;</code> value. Deref coercions turn the reference to <code>MyBox</code> into a reference to <code>String</code> by calling <code>MyBox</code>'s <code>deref</code>. The standard library provides an implementation of <code>Deref</code> on <code>String</code> that returns a string slice. Deref coercions calls <code>deref</code> again to turn the reference to <code>String</code> into a string slice <code>&amp;str</code>, which matches the <code>hello</code> definition.</p>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on <strong>immutable references</strong>, you can use the <code>DerefMut</code> trait to override the <code>*</code> operator on <strong>mutable references</strong>.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>The last case: Rust will also coerce a mutable reference to an immutable one. But the reverse is <strong>not</strong> possible: immutable references will never coerce to mutable references.</p>
<p>Because of the borrowing rules, if you have a <strong>mutable</strong> reference, that mutable reference must be <strong>the only reference</strong> to that data (otherwise, the program wouldn’t compile). Converting one mutable reference to one immutable reference will <strong>never break the borrowing rules</strong>. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don’t guarantee that. Therefore, Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.</p>
<a class="post-dummy-target" id="153-running-code-on-cleanup-with-the-drop-trait"></a><h3>15.3 Running Code on Cleanup with the Drop Trait</h3>
<p>The second trait important to the smart pointer pattern is Drop, which lets you customize what happens when a value is about to go out of scope.</p>
<p>You can use it to release resources like files or network connections. For example, <code>Box&lt;T&gt;</code> customizes <code>Drop</code> to deallocate the space on the heap that the box points to.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">data</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Dropping CustomSmartPointer with data `{}`!&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;my stuff&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;other stuff&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;CustomSmartPointers created.&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="c1">// Output would be:
</span><span class="c1"></span><span class="c1">// CustomSmartPointers created.
</span><span class="c1"></span><span class="c1">// Dropping CustomSmartPointer with data `other stuff`!
</span><span class="c1"></span><span class="c1">// Dropping CustomSmartPointer with data `my stuff`!
</span></code></pre></td></tr></table>
</div>
</div><p><code>data</code> with <code>String</code> type of <code>CustomSmartPointer</code> instances will be released by the compiler because they are on stack.</p>
<p><code>d</code> was dropped before <code>c</code> because variables are dropped in the reverse order of their creation.</p>
<a class="post-dummy-target" id="dropping-a-value-early-with-stdmemdrop"></a><h4>Dropping a Value Early with <code>std::mem::drop</code></h4>
<p>Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage <strong>locks</strong>: you might want to force the <code>drop</code> method that releases the lock to run so other code in the same scope can acquire the lock. Rust doesn’t let you call the <code>Drop</code> trait’s <code>drop</code> method manually; instead you have to call the <code>std::mem::drop</code> function provided by the standard library if you want to force a value to be dropped before the end of its scope.</p>
<a class="post-dummy-target" id="154-rct-the-reference-counted-smart-pointer"></a><h3>15.4 <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</h3>
<p>To enable multiple ownership (a single value has multiple owners), Rust has a type called <code>Rc&lt;T&gt;</code>, which is an abbreviation for <strong>reference counting</strong>. The <code>Rc&lt;T&gt;</code> type keeps track of the <strong>number of references</strong> to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to <strong>allocate some data on the heap</strong> for <strong>multiple</strong> parts of our program to <strong>read</strong> and we can’t determine at compile time which part will finish using the data last.</p>
<p><strong>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios.</strong></p>
<a class="post-dummy-target" id="using-rct-to-share-data"></a><h4>Using <code>Rc&lt;T&gt;</code> to Share Data</h4>
<p>Recall that we defined cons list using <code>Box&lt;T&gt;</code>. This time, we’ll create two lists that both share ownership of a third list.
<figure><img src="/forgetful/svg/loading.min.svg" data-sizes="auto" data-src="/images/rust-rc-share-data.svg" alt="" class="lazyload"></figure>
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Cons</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Nil</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">List</span>::<span class="p">{</span><span class="n">Cons</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Nil</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;count after creating a = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;count after creating b = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;count after creating c = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;count after c goes out of scope = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Rc::clone(&amp;a)</code> is used here rather than <code>a.clone()</code>, because <code>a.clone()</code> is more like the deep copy of most types&rsquo; implementations of <code>clone</code> do. While <code>Rc::clone</code> doesn&rsquo;t do deep copy, it only increments the reference count, which doesn&rsquo;t take much time.</p>
<p>The implementation of the <code>Drop</code> trait decreases the reference count automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</p>
<p><code>Rc&lt;T&gt;</code> only allow you to have immutable references. With <code>RefCell&lt;T&gt;</code> type you can work with immutable references.</p>
<a class="post-dummy-target" id="155-refcellt-and-the-interior-mutability-pattern"></a><h3>15.5 <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</h3>
<p><code>Interior mutability</code> is a design pattern in Rust that <strong>allows you to mutate</strong> data even when there are <strong>immutable references</strong> to that data; normally, this action is <strong>disallowed</strong> by the borrowing rules. To mutate data, the pattern uses <strong>unsafe</strong> code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing.</p>
<p>We can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be <strong>followed at runtime</strong>, even though the compiler can’t guarantee that. The unsafe code involved is then wrapped in a safe API, and <strong>the outer type is still immutable</strong>.</p>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data it holds. So, what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code>?</p>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced <strong>at compile time</strong>. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <strong>at runtime</strong>. With references, if you break these rules, you’ll get a <strong>compiler error</strong>. With <code>RefCell&lt;T&gt;</code>, if you break these rules, your program will <strong>panic and exit</strong>.</p>
<p>The <code>RefCell&lt;T&gt;</code> type is useful when <strong>you</strong>’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</p>
<p>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in <strong>single-threaded</strong> scenarios and will give you a compile-time error if you try using it in a multithreaded context.</p>
<a class="post-dummy-target" id="boxt-vs-rct-vs-refcellt"></a><h4><code>Box&lt;T&gt;</code> vs. <code>Rc&lt;T&gt;</code> vs. <code>RefCell&lt;T&gt;</code></h4>
<ul>
<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> have single owners.</li>
<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code> allows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is immutable.</li>
</ul>
<a class="post-dummy-target" id="a-use-case-for-interior-mutability-mock-objects"></a><h4>A Use Case for Interior Mutability: Mock Objects</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Messenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// taking immutable reference to `self`
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">LimitTracker</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Messenger</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">messenger</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">value</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">max</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LimitTracker</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Messenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">messenger</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">max</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">LimitTracker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">LimitTracker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">messenger</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">value</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">max</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">set_value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">max</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">&gt;</span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">messenger</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&#34;Error: You are over your quota!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">&gt;</span><span class="o">=</span><span class="w"> </span><span class="mf">0.9</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">             </span><span class="bp">self</span><span class="p">.</span><span class="n">messenger</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&#34;Urgent warning: You&#39;ve used up over 90% of your quota!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">&gt;</span><span class="o">=</span><span class="w"> </span><span class="mf">0.75</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">messenger</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&#34;Warning: You&#39;ve used up over 75% of your quota!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Then we want to mock <code>send</code> method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Can&#39;t compile.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">cfg(test)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">sent_messages</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sent_messages</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Messenger</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">message</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="c1">// Can&#39;t compile because `self` is immutable reference.
</span><span class="c1"></span><span class="w">            </span><span class="c1">// We can&#39;t change `&amp;self` to `&amp;mut self` either, because it&#39;s
</span><span class="c1"></span><span class="w">            </span><span class="c1">// defined in `Messenger`&#39;s signature.
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">it_sends_an_over_75_percent_warning_message</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">mock_messenger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MockMessenger</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">limit_tracker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LimitTracker</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_messenger</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">limit_tracker</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">mock_messenger</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This is a situation in which interior mutability can help.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">cfg(test)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">sent_messages</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">,</span><span class="w">  </span><span class="c1">// use RefCell for interior mutability
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sent_messages</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Messenger</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">message</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="c1">// `borrow_mut` gets a mutable reference to the value inside the
</span><span class="c1"></span><span class="w">            </span><span class="c1">// RefCell&lt;Vec&lt;String&gt;&gt;, which is the vector.
</span><span class="c1"></span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="cp">#[</span><span class="cp">test</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">it_sends_an_over_75_percent_warning_message</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Need to use `borrow` to get an immutable reference to the vector.
</span><span class="c1"></span><span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">mock_messenger</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">borrow</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="keeping-track-of-borrows-at-runtime-with-refcellt"></a><h4>Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></h4>
<p>With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code> methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The <code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code> returns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code>, so we can treat them like regular references.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code> increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of <code>RefCell&lt;T&gt;</code> will <strong>panic at runtime</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Can&#39;t compile.
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Messenger</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">message</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Two mutable references in the same scope isn&#39;t allowed.
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">one_borrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">two_borrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">one_borrow</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">two_borrow</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"></a><h4>Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></h4>
<p>Recall the cons list example above where we used <code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because <code>Rc&lt;T&gt;</code> holds only immutable values, we <strong>can’t change</strong> any of the values in the list once we’ve created them.</p>
<p>We can gain the ability to change the values in the lists with <code>RefCell&lt;T&gt;</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">derive(Debug)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Cons</span><span class="p">(</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">)</span><span class="p">,</span><span class="w">  </span><span class="c1">// use `Rc&lt;RefCell&lt;i32&gt;&gt;` instead of `i32`
</span><span class="c1"></span><span class="w">    </span><span class="n">Nil</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">List</span>::<span class="p">{</span><span class="n">Cons</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// would change it directly
</span><span class="c1"></span><span class="w">  
</span><span class="w">    </span><span class="c1">// Both `a` and `value` have ownership ot the inner `5` value
</span><span class="c1"></span><span class="w">    </span><span class="c1">// because `Rc::clone` is used.
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Nil</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Both `b` and `c` owns `a`.
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// `value` of `Rc` type is dereferenced to `RefCell` automatically,
</span><span class="c1"></span><span class="w">    </span><span class="c1">// then `borrow_mut` of `RefCell` is called to return a `RefMut` smart
</span><span class="c1"></span><span class="w">    </span><span class="c1">// pointer. And we use the dereference operator on it to change the
</span><span class="c1"></span><span class="w">    </span><span class="c1">// inner value.
</span><span class="c1"></span><span class="w">    </span><span class="o">*</span><span class="n">value</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;a after = {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;b after = {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;c after = {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The standard library has other types that provide <strong>interior mutability</strong>, such as <code>Cell&lt;T&gt;</code>, which is similar except that instead of giving references to the inner value, the value is <strong>copied</strong> in and out of the <code>Cell&lt;T&gt;</code>. There’s also <code>Mutex&lt;T&gt;</code>, which offers interior mutability that’s safe to use <strong>across threads</strong>.</p>
<a class="post-dummy-target" id="156-reference-cycles-can-leak-memory"></a><h3>15.6 Reference Cycles Can Leak Memory</h3>
<p>Rust’s memory safety guarantees make it <strong>difficult</strong>, but <strong>not impossible</strong>, to accidentally create memory that is never cleaned up (known as a <code>memory leak</code>).</p>
<p>Preventing memory leaks entirely is <strong>not</strong> one of Rust’s <strong>guarantees</strong> in the same way that disallowing data races at compile time is, meaning memory leaks are memory safe in Rust.</p>
<p>We can see that Rust allows memory leaks by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>: <strong>it’s possible to create references where items refer to each other in a cycle</strong>. This creates memory leaks because the <strong>reference count</strong> of each item in the cycle will <strong>never reach 0</strong>, and the values will never be dropped.</p>
<a class="post-dummy-target" id="creating-a-reference-cycle"></a><h4>Creating a Reference Cycle</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">List</span>::<span class="p">{</span><span class="n">Cons</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">derive(Debug)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Cons</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Nil</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">tail</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Cons</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Nil</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Nil</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;a initial rc count = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: a initial rc count = 1
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;a next item = {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: a next item = Some(RefCell { value: Nil })
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;a rc count after b creation = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: a rc count after b creation = 2
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;b initial rc count = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: b initial rc count = 1
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;b next item = {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">link</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">tail</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="o">*</span><span class="n">link</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;b rc count after changing a = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: b rc count after changing a = 2
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;a rc count after changing a = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: a rc count after changing a = 2
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Uncomment the next line to see that we have a cycle;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// it will overflow the stack
</span><span class="c1"></span><span class="w">    </span><span class="c1">// println!(&#34;a next item = {:?}&#34;, a.tail());
</span><span class="c1"></span><span class="w">    </span><span class="c1">// a: 5 -&gt; b: 10 -&gt; a ....
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Creating <strong>reference cycles</strong> is <strong>not easily done</strong>, but it’s <strong>not impossible</strong> either. If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested combinations of types with interior mutability and reference counting, <strong>you</strong> must ensure that you don’t create cycles; you <strong>can’t rely on Rust</strong> to catch them. Creating a reference cycle would be a logic bug in your program that you should use automated tests, code reviews, and other software development practices to minimize.</p>
<p><strong>Another solution for avoiding reference cycles</strong> is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and <strong>only the ownership relationships affect whether or not a value can be dropped</strong>.</p>
<p>However, reorganizing <strong>doesn&rsquo;t</strong> work well all the time. For example, in the cons list example, we always want Cons variants to own their list, so reorganizing the data structure isn’t possible.</p>
<p>But in graphs which are made up of parent nodes and child nodes  <strong>non-ownership relationships are an appropriate way to prevent reference cycles</strong>.</p>
<a class="post-dummy-target" id="preventing-reference-cycles-turning-an-rct-into-a-weakt"></a><h4>Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></h4>
<p>Given <code>let x = Rc::new...</code>,</p>
<p><code>Rc::clone(&amp;x)</code> increases the <code>strong_count</code> of <code>x</code>, and <code>x</code> is only cleaned up if its <code>strong_count</code> is 0.</p>
<p>Calling <code>Rc::downgrade(&amp;x)</code>, you get a smart pointer of type <code>Weak&lt;T&gt;</code>, called a <strong>weak reference</strong>. It increases the <code>weak_count</code> by 1. The <code>weak_count</code> doesn&rsquo;t need to be 0 for <code>x</code> to be cleaned up.</p>
<p><strong>Weak references don’t express an ownership relationship.</strong> They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references <strong>might have been dropped</strong>, to do anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, you must make sure the value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code> instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code> if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the <code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;T&gt;</code>, Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there won’t be an invalid pointer.</p>
<p>Example of <code>tree</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="p">{</span><span class="n">Rc</span><span class="p">,</span><span class="w"> </span><span class="n">Weak</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Node only owns its children. If a Node is dropped, its children should
</span><span class="c1"></span><span class="c1">// be dropped as well. However, a child should not own its parent. This 
</span><span class="c1"></span><span class="c1">// is a case for weak reference!
</span><span class="c1"></span><span class="cp">#[</span><span class="cp">derive(Debug)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Can’t contain an Rc&lt;T&gt; for parent, because that would create a
</span><span class="c1"></span><span class="w">    </span><span class="c1">// reference cycle with `leaf.parent` pointing to `branch` and 
</span><span class="c1"></span><span class="w">    </span><span class="c1">// `branch.children` pointing to `leaf`, which would cause their
</span><span class="c1"></span><span class="w">    </span><span class="c1">// `strong_count` values to never be 0.
</span><span class="c1"></span><span class="w">    </span><span class="n">parent</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">,</span><span class="w">  </span><span class="c1">// weak reference to its parent
</span><span class="c1"></span><span class="w">    </span><span class="n">children</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">value</span>: <span class="mi">3</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">parent</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Weak</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">  </span><span class="c1">// initial parent is empty
</span><span class="c1"></span><span class="w">        </span><span class="n">children</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="s">&#34;leaf strong = {}, weak = {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Rc</span>::<span class="n">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: leaf strong = 1, weak = 0.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">branch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">value</span>: <span class="mi">5</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">parent</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Weak</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">children</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)</span><span class="p">]</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Set `leaf`&#39;s parent to `branch` using `RefCell`&#39;s `borrow_mut`.
</span><span class="c1"></span><span class="w">        </span><span class="o">*</span><span class="n">leaf</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="s">&#34;branch strong = {}, weak = {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Rc</span>::<span class="n">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">branch</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Output: branch strong = 1, weak = 1.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="s">&#34;leaf strong = {}, weak = {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">Rc</span>::<span class="n">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Output: leaf strong = 2, weak = 0.
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// When this scope ends, `branch` goes out of scope and its `strong_count`
</span><span class="c1"></span><span class="w">    </span><span class="c1">// decreases to 0. So its `Node` is dropped, while `leaf` is dropped too
</span><span class="c1"></span><span class="w">    </span><span class="c1">// and because `leaf` is a `Rc`, only `strong_count` decreases to 1.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;leaf parent = {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">leaf</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">borrow</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">upgrade</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: leaf parent = None
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="s">&#34;leaf strong = {}, weak = {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Rc</span>::<span class="n">weak_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Output: leaf strong = 1, weak = 0.
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="summary"></a><h4>Summary</h4>
<ul>
<li>The <code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap.</li>
<li>The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so that data can have multiple owners.</li>
<li>The <code>RefCell&lt;T&gt;</code> type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</li>
</ul>
<a class="post-dummy-target" id="16-fearless-concurrency"></a><h2>16 Fearless Concurrency</h2>
<p><code>Concurrent programming</code>, where different parts of a program execute independently, and <code>parallel programming</code>, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors.</p>
<a class="post-dummy-target" id="161-using-threads-to-run-code-simultaneously"></a><h3>16.1 Using Threads to Run Code Simultaneously</h3>
<p>The negative effects of using threads:</p>
<ul>
<li>Race conditions, where threads are accessing data or resources in an inconsistent order.</li>
<li>Deadlocks, where two threads are waiting for each other to finish using a resource the other thread has, preventing both threads from continuing.</li>
<li>Bugs that happen only in certain situations and are hard to reproduce and fix reliably.</li>
</ul>
<p>Programming languages implement threads in a few different ways. Many operating systems provide an API for creating new threads. This model where a language calls the operating system APIs to create threads is sometimes called <strong>1:1</strong>, meaning one operating system thread per one language thread.</p>
<p>Many programming languages provide their own special implementation of threads. Programming language-provided threads are known as <code>green</code> threads, and languages that use these green threads will execute them in the context of a different number of operating system threads. For this reason, the green-threaded model is called the <strong>M:N</strong> model: there are M green threads per N operating system threads, where M and N are not necessarily the same number.</p>
<p>The green-threading M:N model requires a larger language <strong>runtime</strong> (code that is included by the language in every binary) to manage threads. As such, the <strong>Rust</strong> standard library only provides an implementation of <strong>1:1</strong> threading. Because Rust is such a low-level language, there are crates that implement <strong>M:N</strong> threading if you would rather trade <strong>overhead</strong> for aspects such as <strong>more control</strong> over which threads run when and <strong>lower costs of context switching</strong>, for example.</p>
<a class="post-dummy-target" id="creating-a-new-thread-with-spawn"></a><h4>Creating a New Thread with <code>spawn</code></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Call `thread::spawn` with a closure.
</span><span class="c1"></span><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi number {} from the spawned thread!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi number {} from the main thread!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="waiting-for-all-threads-to-finish-using-join-handles"></a><h4>Waiting for All Threads to Finish Using <code>join</code> Handles</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// `thread::spawn` returns a `JoinHandle`, calling the `join` on the 
</span><span class="c1"></span><span class="w">    </span><span class="c1">// `JoinHandle` will wait for its thread to finish.
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi number {} from the spawned thread!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi number {} from the main thread!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="using-move-closures-with-threads"></a><h4>Using <code>move</code> Closures with Threads</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// Cann&#39;t compile without `move`.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// let handle = thread::spawn(|| {
</span><span class="c1"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Here&#39;s a vector: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="162-using-message-passing-to-transfer-data-between-threads"></a><h3>16.2 Using Message Passing to Transfer Data Between Threads</h3>
<p>Go&rsquo;s slogan: <strong>&ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&quot;</strong></p>
<p>Channels in Rust.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">mpsc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// mpsc for multiple producer single consumer
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// or use try_recv which doesn&#39;t block
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Got: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">received</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The <code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiving end has already been dropped and there’s nowhere to send a value, the <code>send</code> operation will return an error.</p>
<p>The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code>. We’re using <code>recv</code>, short for receive, which will <strong>block</strong> the main thread’s execution and wait until a value is sent down the channel. Once a value is sent, <code>recv</code> will return it in a <code>Result&lt;T, E&gt;</code>. When the sending end of the channel closes, <code>recv</code> will return an error to signal that no more values will be coming.</p>
<p>The <code>try_recv</code> method <strong>doesn’t block</strong>, but will instead return a <code>Result&lt;T, E&gt;</code> immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code> value if there aren’t any messages this time. <strong>Using <code>try_recv</code> is useful if this thread has other work to do while waiting for messages: we could write a loop that calls <code>try_recv</code> every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</strong></p>
<p>When the <code>val</code> is sent down the channel via <code>tx.send</code>, the <code>send</code> function takes ownership of its parameter, and when the value is moved, <strong>the receiver takes ownership of it</strong>.</p>
<a class="post-dummy-target" id="creating-multiple-producers-by-cloning-the-transmitter"></a><h4>Creating Multiple Producers by Cloning the Transmitter</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">channel</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">tx1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span>::<span class="n">Sender</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// now we have two producers, `tx` and `tx1`
</span><span class="c1"></span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;from&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;the&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;thread&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">tx1</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;more&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;messages&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;for&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;you&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Got: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">received</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// --snip--
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="163-shared-state-concurrency"></a><h3>16.3 Shared-State Concurrency</h3>
<p>Channels are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time.</p>
<a class="post-dummy-target" id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"></a><h4>Using Mutexes to Allow Access to Data from One Thread at a Time</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">Mutex</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">  </span><span class="c1">// num goes out of scope with unlocking the lock
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;m = {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The <code>lock</code> method is used to acquire the lock. It would block the current thread until it&rsquo;s our turn to have the lock. The call to <code>lock</code> would fail if another thread holding the lock panicked.</p>
<p><code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call to <code>lock</code> returns a smart pointer called <code>MutexGuard</code>, wrapped in a <code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> smart pointer implements <code>Deref</code> to point at our inner data; the smart pointer also has a <code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope above.</p>
<a class="post-dummy-target" id="multiple-ownership-with-multiple-threads"></a><h4>Multiple Ownership with Multiple Threads</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="p">{</span><span class="n">Mutex</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// let counter = Mutex::new(0); doesn&#39;t work here because counter can&#39;t
</span><span class="c1"></span><span class="w">    </span><span class="c1">// move to multiple threads&#39; closures.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// let counter = Rc::new(Mutex::new(0)); doesn&#39;t work either because `Rc`
</span><span class="c1"></span><span class="w">    </span><span class="c1">// is not safe to share across threads. 
</span><span class="c1"></span><span class="w">    </span><span class="c1">// `Arc` means atomic reference counting, which is safe to use in concurrent
</span><span class="c1"></span><span class="w">    </span><span class="c1">// situations.
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">.</span><span class="p">.</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">handles</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">handles</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Result: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to. If you’re just performing operations on values within a single thread, your code can run faster if it doesn’t have to enforce the guarantees atomics provide.</p>
<a class="post-dummy-target" id="similarities-between-refcelltrct-and-mutextarct"></a><h4>Similarities Between <code>RefCell&lt;T&gt;/Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;/Arc&lt;T&gt;</code></h4>
<p>The <code>counter</code> is immutable but we could get a mutable reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior mutability, as the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code> to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use <code>Mutex&lt;T&gt;</code> to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>Using <code>Rc&lt;T&gt;</code> came with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to each other, <strong>causing memory leaks</strong>. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of <strong>creating deadlocks</strong>. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever.</p>
<a class="post-dummy-target" id="164-extensible-concurrency-with-the-sync-and-send-traits"></a><h3>16.4 Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</h3>
<a class="post-dummy-target" id="allowing-transference-of-ownership-between-threads-with-send"></a><h4>Allowing Transference of Ownership Between Threads with <code>Send</code></h4>
<p>The <code>Send</code> marker trait indicates that <strong>ownership</strong> of the type implementing <code>Send</code> can be <strong>transferred between threads</strong>. Almost every Rust type is <code>Send</code>, but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this cannot be <code>Send</code> because if you cloned an <code>Rc&lt;T&gt;</code> value and tried to transfer ownership of the clone to another thread, <strong>both threads might update the reference count at the same time</strong>. For this reason, <code>Rc&lt;T&gt;</code> is implemented for use in single-threaded situations where you don’t want to pay the thread-safe performance penalty.</p>
<p>Any type composed <strong>entirely</strong> of <code>Send</code> types is <strong>automatically</strong> marked as <code>Send</code> as well. Almost all <strong>primitive</strong> types are <code>Send</code>, aside from raw pointers.</p>
<a class="post-dummy-target" id="allowing-access-from-multiple-threads-with-sync"></a><h4>Allowing Access from Multiple Threads with Sync</h4>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing <code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is <code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code>, meaning the reference can be sent safely to another thread. Similar to <code>Send</code>, <strong>primitive types</strong> are <code>Sync</code>, and types <strong>composed entirely</strong> of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<a class="post-dummy-target" id="17-object-oriented-programming-features-of-rust"></a><h2>17 Object Oriented Programming Features of Rust</h2>
<a class="post-dummy-target" id="171-characteristics-of-object-oriented-languages"></a><h3>17.1 Characteristics of Object-Oriented Languages</h3>
<p>OOP languages share certain common characteristics, <strong>namely objects</strong>, <strong>encapsulation</strong>, and <strong>inheritance</strong>.</p>
<a class="post-dummy-target" id="objects-contain-data-and-behavior"></a><h4>Objects Contain Data and Behavior</h4>
<p><code>The Gang of Four</code> book defines OOP this way:</p>
<pre><code>Object-oriented programs are made up of objects. An object packages both data and the procedures that operate on that data. The procedures are typically called methods or operations.
</code></pre>
<p>Using this definition, Rust is object oriented: structs and enums have data, and <code>impl</code> blocks provide methods on structs and enums.</p>
<a class="post-dummy-target" id="encapsulation-that-hides-implementation-details"></a><h4>Encapsulation that Hides Implementation Details</h4>
<p>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use <code>pub</code> or not for different parts of code enables encapsulation of implementation details.</p>
<a class="post-dummy-target" id="inheritance-as-a-type-system-and-as-code-sharing"></a><h4>Inheritance as a Type System and as Code Sharing</h4>
<p>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct’s fields and method implementations.</p>
<p>You choose inheritance for two main reasons. <strong>One is for reuse of code</strong>: you can implement particular behavior for one type, and inheritance enables you to reuse that implementation for a different type. You can share Rust code <strong>using default trait method implementations</strong> instead.</p>
<p><strong>The other reason to use inheritance</strong> relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called <strong>polymorphism</strong>, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics. Rust instead uses <strong>generics to abstract over different possible types</strong> and <strong>trait bounds</strong> to impose constraints on what those types must provide. This is sometimes called <code>bounded parametric polymorphism</code>. Also Rust provides <strong>trait objects</strong> to enable polymorphism.</p>
<p>Inheritance has recently fallen out of favor as a programming design solution in many programming languages.</p>
<a class="post-dummy-target" id="172-using-trait-objects-that-allow-for-values-of-different-types"></a><h3>17.2 Using Trait Objects That Allow for Values of Different Types</h3>
<a class="post-dummy-target" id="defining-a-trait-for-common-behavior"></a><h4>Defining a Trait for Common Behavior</h4>
<p>Trait objects are more like objects in other languages in the sense that they <strong>combine data and behavior</strong>. But trait objects differ from traditional objects in that we can’t add data to a trait object. Trait objects aren’t as generally useful as objects in other languages: their specific purpose is to allow <strong>abstraction across common behavior</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// First we need a trait.
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// A struct holds a vector of components.
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Screen</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Here `Box&lt;dyn Draw&gt;` is a trait object.
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">components</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Draw</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">,</span><span class="w">  </span><span class="c1">// any type inside a `Box` that
</span><span class="c1"></span><span class="w">                                         </span><span class="c1">// implements the `Draw` trait
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Screen</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">component</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>In this example, the trait object is a <code>Box</code>. We create a trait object by specifying some sort of pointer, such as a <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart pointer, then the <code>dyn</code> keyword, and then specifying the relevant trait.</p>
<p>This works differently from defining a struct that <strong>uses a generic type parameter with trait bounds</strong>. <strong>A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime</strong>. For example, we could have defined the <code>Screen</code> struct using a generic type and a trait bound as this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Screen</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Draw</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">components</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Screen</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Draw</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">component</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This restricts us to a <code>Screen</code> instance that has a list of components all of type <code>Button</code> or all of type <code>TextField</code>. If you’ll only ever have <strong>homogeneous collections</strong>, using <strong>generics and trait bounds</strong> is preferable because the definitions will be monomorphized at compile time to use the concrete types.</p>
<p>On the other hand, with the method using <strong>trait objects</strong>, one <code>Screen</code> instance can hold a <code>Vec&lt;T&gt;</code> that contains a <code>Box&lt;Button&gt;</code> as well as a <code>Box&lt;TextField&gt;</code>.</p>
<a class="post-dummy-target" id="implementing-the-trait"></a><h4>Implementing the Trait</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Published with our gui crate.
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Button</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">width</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">label</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Button</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// code to actually draw a button
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Our library&#39;s user defines their own type.
</span><span class="c1"></span><span class="k">use</span><span class="w"> </span><span class="n">gui</span>::<span class="n">Draw</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SelectBox</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">width</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">options</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SelectBox</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// code to actually draw a select box
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">gui</span>::<span class="p">{</span><span class="n">Screen</span><span class="p">,</span><span class="w"> </span><span class="n">Button</span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">screen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Screen</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">components</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">SelectBox</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">width</span>: <span class="mi">75</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">height</span>: <span class="mi">10</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">options</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Yes&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Maybe&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                    </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;No&#34;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="p">]</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Button</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">width</span>: <span class="mi">50</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">height</span>: <span class="mi">10</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">label</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;OK&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">}</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">]</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">screen</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>When we wrote the library, we didn’t know that someone might add the <code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> trait, which means it implements the <code>draw</code> method.</p>
<p>This concept—of being concerned only with the messages a value responds to rather than the value’s concrete type—is similar to the concept <strong>duck typing</strong> in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code> in above code, <code>run</code> doesn’t need to know what the concrete type of each component is. It doesn’t check whether a component is an instance of a <code>Button</code> or a <code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By specifying <code>Box&lt;dyn Draw&gt;</code> as the type of the values in the components vector, we’ve defined <code>Screen</code> to need values that we can call the <code>draw</code> method on.</p>
<p>The advantage of using <strong>trait objects</strong> and <strong>Rust’s type system</strong> to write code similar to code using duck typing is that we <strong>never</strong> have to check whether a value implements a particular method at <strong>runtime</strong> or worry about getting errors if a value doesn’t implement a method but we call it anyway. Rust <strong>won’t compile</strong> our code if the values don’t implement the traits that the trait objects need.</p>
<a class="post-dummy-target" id="trait-objects-perform-dynamic-dispatch"></a><h4>Trait Objects Perform Dynamic Dispatch</h4>
<p>The monomorphization process performed by the compiler when we use trait bounds on generics: the compiler <strong>generates</strong> nongeneric implementations of functions and methods <strong>for each concrete type</strong> that we use in place of a generic type parameter. The code that results from monomorphization is doing <strong>static dispatch</strong>, which is when the compiler knows what method you’re calling <strong>at compile time</strong>. This is opposed to <strong>dynamic dispatch</strong>, which is when the compiler can’t tell at compile time which method you’re calling. In dynamic dispatch cases, the compiler emits code that <strong>at runtime</strong> will figure out which method to call.</p>
<p>When we use <strong>trait objects</strong>, Rust must use <strong>dynamic dispatch</strong>. The compiler doesn’t know all the types that might be used with the code that is using trait objects, so it doesn’t know which method implemented on which type to call. Instead, at runtime, Rust uses the <strong>pointers</strong> inside the trait object to know which method to call. There is <strong>a runtime cost</strong> when this lookup happens that doesn’t occur with static dispatch. <strong>Dynamic dispatch also prevents the compiler from choosing to inline a method’s code, which in turn prevents some optimizations.</strong></p>
<a class="post-dummy-target" id="object-safety-is-required-for-trait-objects"></a><h4>Object Safety Is Required for Trait Objects</h4>
<p>TODO: NOT CLEAR</p>
<a class="post-dummy-target" id="173-implementing-an-object-oriented-design-pattern"></a><h3>17.3 Implementing an Object-Oriented Design Pattern</h3>
<p>Implemented here: <code>~/git/playground/trpl/chap_17/blog</code>.</p>
<p>This example shows that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state.</p>
<p>One <strong>downside</strong> of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other.</p>
<p>Another <strong>downside</strong> is that we’ve duplicated some logic.</p>
<p>By implementing the state pattern exactly as it’s defined for object-oriented languages, we’re <strong>not taking as full advantage of Rust</strong>’s strengths as we could.</p>
<a class="post-dummy-target" id="we-could-leverage-rusts-type-checking-system-more-to-issue-compiler-errors"></a><h4>We could leverage Rust&rsquo;s type checking system more to issue compiler errors.</h4>
<p>The steps to refactor our state OOP pattern to a Rust one:</p>
<a class="post-dummy-target" id="encoding-states-and-behavior-as-types"></a><h4>Encoding States and Behavior as Types</h4>
<a class="post-dummy-target" id="implementing-transitions-as-transformations-into-different-types"></a><h4>Implementing Transitions as Transformations into Different Types</h4>
<p>Although you might be very familiar with object-oriented patterns, <strong>rethinking</strong> the problem to take advantage of Rust’s features can provide benefits, such as preventing some bugs at <strong>compile time</strong>. Object-oriented patterns won’t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don’t have.</p>
<a class="post-dummy-target" id="18-patterns-and-matching"></a><h2>18 Patterns and Matching</h2>
<a class="post-dummy-target" id="181-all-the-places-patterns-can-be-used"></a><h3>18.1 All the Places Patterns Can Be Used</h3>
<a class="post-dummy-target" id="match-arms"></a><h4><code>match</code> Arms</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">match</span><span class="w"> </span><span class="n">VALUE</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">PATTERN</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EXPRESSION</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">PATTERN</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EXPRESSION</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">PATTERN</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EXPRESSION</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Note that it is a expression followed the pattern.</p>
<p>A particular pattern <code>_</code> will <strong>match anything</strong>, but it never binds to a variable, so it’s often used in <strong>the last match arm</strong>.</p>
<a class="post-dummy-target" id="conditional-if-let-expressions"></a><h4>Conditional <code>if let</code> Expressions</h4>
<p><code>if let</code> expressions mainly as a shorter way to write the equivalent of a match that only matches one case.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">favorite_color</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">is_tuesday</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;34&#34;</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">color</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">favorite_color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Using your favorite color, {}, as the background&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">is_tuesday</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Tuesday is green day!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// introduce a new shadowed `age` as well
</span><span class="c1"></span><span class="w">        </span><span class="c1">// But can&#39;t use `else if let Ok(age) = age &amp;&amp; age &gt; 30` here
</span><span class="c1"></span><span class="w">        </span><span class="c1">// because the shadowed `age` isn&#39;t valid until the new scop starts
</span><span class="c1"></span><span class="w">        </span><span class="c1">// with the curly bracket. 
</span><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Using purple as the background color&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Using orange as the background color&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Using blue as the background color&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="while-let-conditional-loops"></a><h4><code>while let</code> Conditional Loops</h4>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a while loop to run for as long as a pattern continues to match.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">top</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="for-loops"></a><h4><code>for</code> Loops</h4>
<p>In a <code>for</code> loop, the pattern is the value that directly follows the keyword <code>for</code>, so in <code>for x in y</code> the <code>x</code> is the pattern.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">enumerate</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} is at index {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="let-statements"></a><h4><code>let</code> Statements</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">PATTERN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EXPRESSION</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// For example:
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Use <code>_</code> or <code>..</code> to ignore one ro more of the values in the tuple.</p>
<a class="post-dummy-target" id="function-parameters"></a><h4>Function Parameters</h4>
<p>Function parameters can also be patterns as <code>let</code> statements.</p>
<a class="post-dummy-target" id="182-refutability-whether-a-pattern-might-fail-to-match"></a><h3>18.2 Refutability: Whether a Pattern Might Fail to Match</h3>
<p>Patterns come in two forms: <strong>refutable</strong> and <strong>irrefutable</strong>. Patterns that will match for any possible value passed are <strong>irrefutable</strong>. An example would be <code>x</code> in the statement <code>let x = 5;</code> because <code>x</code> matches anything and therefore cannot fail to match. Patterns that can fail to match for some possible value are <strong>refutable</strong>. An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than <code>Some</code>, the <code>Some(x)</code> pattern will not match.</p>
<p>Irrefutable patterns: function parameters, let statements, and for loops. Because the program cannot do anything meaningful when values don’t match.</p>
<p>Refutable patterns: <code>if let</code>, <code>while let</code>.</p>
<a class="post-dummy-target" id="183-pattern-syntax"></a><h3>18.3 Pattern Syntax</h3>
<a class="post-dummy-target" id="matching-literals"></a><h4>Matching Literals</h4>
<a class="post-dummy-target" id="matching-named-variables"></a><h4>Matching Named Variables</h4>
<a class="post-dummy-target" id="multiple-patterns"></a><h4>Multiple Patterns</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;one or two&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;anything&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="matching-ranges-of-values-with-"></a><h4>Matching Ranges of Values with <code>..=</code></h4>
<p>The only types for which Rust can tell if a range is empty or not are <code>char</code> and numeric values.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="mi">1</span><span class="p">.</span><span class="p">.</span><span class="o">=</span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;one through five&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;something else&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="destructuring-to-break-apart-values"></a><h4>Destructuring to Break Apart Values</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Destructuring structs.
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">7</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Shortcut for `let Point {x: x, y: y} = p;`
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Destructuring and matching part of the struct.
</span><span class="c1"></span><span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;On the x axis at {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;On the y axis at {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;On neither axis: ({}, {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Destructuring Enums.
</span><span class="c1"></span><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Quit</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span> <span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">ChangeColor</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">Quit</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The Quit variant has no data to destructure.&#34;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="s">&#34;Move in the x direction {} and in the y direction {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">y</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">Write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Text message: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="s">&#34;Change the color to red {}, green {}, and blue {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">b</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Destructuring Nested Structs and Enums
</span><span class="c1"></span><span class="k">enum</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">   </span><span class="n">Rgb</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">   </span><span class="n">Hsv</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Quit</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span> <span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span>::<span class="n">Hsv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span>::<span class="n">Rgb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="s">&#34;Change the color to red {}, green {}, and blue {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">b</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span>::<span class="n">Hsv</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="s">&#34;Change the color to hue {}, saturation {}, and value {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">h</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">s</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">v</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Destructuring Structs and Tuples.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="p">(</span><span class="n">feet</span><span class="p">,</span><span class="w"> </span><span class="n">inches</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="o">-</span><span class="mi">10</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="ignoring-values-in-a-pattern"></a><h4>Ignoring Values in a Pattern</h4>
<ol>
<li>Ignoring an Entire Value with <code>_</code></li>
</ol>
<p>We’ve used the underscore (<code>_</code>) as a <strong>wildcard</strong> pattern that will match any value but <strong>not bind to the value</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Using `_` to ignore a function parameter.
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">_</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;This code only uses the y parameter: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>Ignoring Parts of a Value with a Nested <code>_</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">fifth</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Some numbers: {}, {}, {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">,</span><span class="w"> </span><span class="n">fifth</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Ignoring an Unused Variable by Starting Its Name with <code>_</code></li>
</ol>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name that starts with an underscore. The syntax <code>_x</code> still binds the value to the variable, whereas <code>_</code> doesn’t bind at all.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello!&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Can&#39;t compile if using `_s` like below, because `s` is moved to `_s`.
</span><span class="c1"></span><span class="c1">// if let Some(_s) = s {
</span><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;found a string&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>Ignoring Remaining Parts of a Value with <code>..</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">z</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">z</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Equivalent to `Point { x, y, z }`.
</span><span class="c1"></span><span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;x is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Some numbers: {}, {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="extra-conditionals-with-match-guards"></a><h4>Extra Conditionals with Match Guards</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;less than five: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="-bindings"></a><h4><code>@</code> Bindings</h4>
<p>An example where we want to <strong>test</strong> that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. But we also want to <strong>bind</strong> the value to the variable <code>id_variable</code> so we can use it in the code associated with the arm.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="kt">i32</span> <span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="mi">5</span><span class="w"> </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="nc">id_variable</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span><span class="p">.</span><span class="o">=</span><span class="mi">7</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Found an id in range: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">id_variable</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="mi">10</span><span class="p">.</span><span class="p">.</span><span class="o">=</span><span class="mi">12</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Found an id in another range&#34;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Found some other id: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="19-advanced-features"></a><h2>19 Advanced Features</h2>
<p>Reference when you use them.</p>
<a class="post-dummy-target" id="191-unsafe-rust"></a><h3>19.1 Unsafe Rust</h3>
<p>Unsafe Rust exists because:</p>
<ol>
<li>Static analysis is conservative. In some cases, you can tell the compiler &ldquo;Trust me, I know what I&rsquo;m doing&rdquo; by using unsafe code. Which means that you use it at your own risk.</li>
<li>Underlying computer hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system.</li>
</ol>
<a class="post-dummy-target" id="unsafe-superpowers"></a><h4>Unsafe Superpowers</h4>
<p>These superpowers include the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of <code>union</code>s</li>
</ul>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block that holds the unsafe code.</p>
<p>Keep <code>unsafe</code> blocks small.</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe abstraction and provide a safe API.</p>
<a class="post-dummy-target" id="dereferencing-a-raw-pointer"></a><h4>Dereferencing a Raw Pointer</h4>
<p>Raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;r1 is: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;r2 is: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r2</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>If we instead tried to create an immutable and a mutable reference to <code>num</code>, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race.</p>
<p>Mainly in two use cases:</p>
<ol>
<li>Interfacing with C code.</li>
<li>Building up safe abstractions that the borrow checker doesn’t understand.</li>
</ol>
<a class="post-dummy-target" id="calling-an-unsafe-function-or-method"></a><h4>Calling an Unsafe Function or Method</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dangerous</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">dangerous</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="creating-a-safe-abstraction-over-unsafe-code"></a><h4>Creating a Safe Abstraction over Unsafe Code</h4>
<p>Wrapping unsafe code in a safe function is a common abstraction.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">slice</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">mid</span><span class="w"> </span><span class="o">&lt;</span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">(</span><span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">         </span><span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">mid</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mid</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The <strong>unsafe</strong> code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice. The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid. The <code>offset</code> method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as <code>unsafe</code>, and we can call this function from safe Rust. This way we created a safe abstraction to the unsafe code with an implementation of the function that uses <code>unsafe</code> code in a safe way, because it creates only valid pointers from the data this function has access to.</p>
<a class="post-dummy-target" id="using-extern-functions-to-call-external-code"></a><h4>Using <code>extern</code> Functions to Call External Code</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">abs</span><span class="p">(</span><span class="n">input</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Absolute value of -3 according to C: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Keyword, <code>extern</code>, facilitates the creation and use of a <code>Foreign Function Interface</code> (<code>FFI</code>). An <code>FFI</code> is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external functions from another language we want to call. The <code>&quot;C&quot;</code> part defines which <code>application binary interface</code> (<code>ABI</code>) the external function uses: the <code>ABI</code> defines how to call the function at the assembly level. The <code>&quot;C&quot;</code> ABI is the most common and follows the C programming language’s ABI.</p>
<a class="post-dummy-target" id="calling-rust-functions-from-other-languages"></a><h4>Calling Rust Functions from Other Languages</h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages to call Rust functions. Instead of an <code>extern</code> block, we add the <code>extern</code> keyword and specify the <code>ABI</code> to use just before the fn keyword. We also need to add a <code>#[no_mangle]</code> annotation to tell the Rust compiler not to mangle the name of this function. Mangling is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling.</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from C code, after it’s compiled to a shared library and linked from C:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">no_mangle</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_from_c</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Just called a Rust function from C!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This usage of <code>extern</code> does not require unsafe.</p>
<a class="post-dummy-target" id="accessing-or-modifying-a-mutable-static-variable"></a><h4>Accessing or Modifying a Mutable Static Variable</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="n">HELLO_WORLD</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;Hello, world!&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;name is: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">HELLO_WORLD</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Static variables are similar to constants.</strong></p>
<p><strong>Static variables vs. Constants</strong></p>
<ul>
<li>
<p>Values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used.</p>
</li>
<li>
<p>Static variables can be mutable. Accessing and modifying mutable static variables is <strong>unsafe</strong>.</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">COUNTER</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">add_to_count</span><span class="p">(</span><span class="n">inc</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">COUNTER</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="n">inc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">add_to_count</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// note: it&#39;s unsafe
</span><span class="c1"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;COUNTER: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">COUNTER</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="implementing-an-unsafe-trait"></a><h4>Implementing an Unsafe Trait</h4>
<p>A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify.</p>
<p>Adding the <code>unsafe</code> keyword before trait and marking the implementation of the trait as <code>unsafe</code> too.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// methods go here
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// method implementations go here
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="193-advance-traits"></a><h3>19.3 Advance Traits</h3>
<a class="post-dummy-target" id="specifying-placeholder-types-in-trait-definitions-with-associated-types"></a><h4>Specifying Placeholder Types in Trait Definitions with Associated Types</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">  </span><span class="c1">// this is an associated type
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">  </span><span class="c1">// use the associated type here
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Associated types</strong> connect a type <strong>placeholder</strong> with a trait such that the trait method definitions can use these placeholder types in their signatures.</p>
<a class="post-dummy-target" id="default-generic-type-parameters-and-operator-overloading"></a><h4>Default Generic Type Parameters and Operator Overloading</h4>
<p><strong>Operator overloading</strong> is customizing the behavior of an operator (such as <code>+</code>) in particular situations.</p>
<p>Rust <strong>doesn’t allow</strong> you to create your own operators or overload arbitrary operators. But you can overload the operations and corresponding traits listed in <code>std::ops</code> by implementing the traits associated with the operator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">  </span><span class="c1">// only allow to overload operators in `std::ops`
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="cp">#[</span><span class="cp">derive(Debug, PartialEq)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// need implement `Add` trait to overload `+`
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">3</span><span class="w"> </span><span class="p">}</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">               </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">3</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// The defination of `Add` trait.
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">RHS</span><span class="o">=</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// default type parameter `RHS=Self`
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">RHS</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The <code>RHS</code> generic type parameter allows us to add two different types. But the default type parameter allows us not have to specify the extra parameter most of the time.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Millimeters</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Meters</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Meters</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Millimeters</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Millimeters</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Meters</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Millimeters</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">Millimeters</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Another useful case of default type parameters is <strong>to extend a type without breaking existing code</strong>, that is, if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</p>
<a class="post-dummy-target" id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"></a><h4>Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</h4>
<p>You could implement two traits on one type and there are methods with the same name from these two traits and the type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Pilot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Pilot</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;This is your captain speaking.&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Up!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;*waving arms furiously*&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Pilot</span>::<span class="n">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// need to tell Rust which method to call
</span><span class="c1"></span><span class="w">    </span><span class="n">Wizard</span>::<span class="n">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// need to tell Rust which method to call
</span><span class="c1"></span><span class="w">    </span><span class="n">person</span><span class="p">.</span><span class="n">fly</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// output: *waving arms furiously*
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Three <code>fly</code> methods are implemented.</p>
<p>Because the <code>fly</code> method accepts <code>self</code> as a parameter, if two types, <code>Human</code> and <code>Dog</code> implement <code>Pilot</code> trait, Rust can tell which type&rsquo;s <code>fly</code> to call based on the type of <code>self</code>.</p>
<p>But if the trait method doesn&rsquo;t accept <code>self</code> as its parameter, in which case, the method is an associated function. <strong>Fully qualified syntax</strong> is needed in this case.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">baby_name</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Dog</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">baby_name</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Spot&#34;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">baby_name</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;puppy&#34;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Not compile. Rust can&#39;t figure out which implementation to use.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// println!(&#34;A baby dog is called a {}&#34;, Animal::baby_name());
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;A baby dog is called a {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Dog</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Animal</span><span class="o">&gt;</span>::<span class="n">baby_name</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="using-supertraits-to-require-one-traits-functionality-within-another-trait"></a><h4>Using Supertraits to Require One Trait’s Functionality Within Another Trait</h4>
<p><code>Display</code> trait is the <strong>supertrait</strong> of <code>OutlinePrint</code> trait.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">OutlinePrint</span>: <span class="nc">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// OutlinePrint depends on Display
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Prints like:
</span><span class="c1"></span><span class="w">    </span><span class="c1">// **********
</span><span class="c1"></span><span class="w">    </span><span class="c1">// *        *
</span><span class="c1"></span><span class="w">    </span><span class="c1">// * (1, 3) *
</span><span class="c1"></span><span class="w">    </span><span class="c1">// *        *
</span><span class="c1"></span><span class="w">    </span><span class="c1">// **********
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">outline_print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">  </span><span class="c1">// to_string is Display&#39;s function
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">len</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;*&#34;</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;*{}*&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;* {} *&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;*{}*&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;*&#34;</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">OutlinePrint</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;({}, {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"></a><h4>Using the Newtype Pattern to Implement External Traits on External Types</h4>
<p>Rust has the orphan rule that states we’re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It’s possible to get around this restriction using the <strong>newtype pattern</strong>, which involves creating a new type in a <strong>tuple struct</strong>. The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper.</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the orphan rule prevents us from doing directly because the <code>Display</code> trait and the <code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on <code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Wrapper</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;[{}]&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">join</span><span class="p">(</span><span class="s">&#34;, &#34;</span><span class="p">)</span><span class="p">)</span><span class="w">  </span><span class="c1">// notice the `self.0`
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Wrapper</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">)</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;w = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it <strong>doesn’t have the methods</strong> of the value it’s holding. We would have to implement all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a <code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has, implementing the <code>Deref</code> trait on the <code>Wrapper</code> to return the inner type would be a solution. If we don’t want the <code>Wrapper</code> type to have all the methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s behavior—we would have to implement just the methods we do want manually.</p>
<a class="post-dummy-target" id="194-advanced-types"></a><h3>19.4 Advanced Types</h3>
<a class="post-dummy-target" id="using-the-newtype-pattern-for-type-safety-and-abstraction"></a><h4>Using the Newtype Pattern for Type Safety and Abstraction</h4>
<p><strong>Type Safety</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Millimeters</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Meters</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Millimeters</code> and <code>Meters</code> wrap <code>u32</code> values in a newtype, which enforces these two are different types.</p>
<p>If we worte a function with a parameter of type <code>Meters</code>, we couldn&rsquo;t compile a program that accidentally tried to call that function with a value of type <code>Millimeters</code> or a plain <code>u32</code>.</p>
<p><strong>Abstraction</strong>
Another use of the newtype pattern is in <strong>abstracting</strong> away some implementation details of a type: the new type can expose a <strong>public API</strong> that is different from the API of the <strong>private inner type</strong> if we used the new type directly to restrict the available functionality, for example.</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a <code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID associated with their name. Code using <code>People</code> would only interact with the public API we provide, such as a method to add a name string to the <code>People</code> collection; that code wouldn’t need to know that we assign an <code>i32</code> ID to names internally.</p>
<a class="post-dummy-target" id="creating-type-synonyms-with-type-aliases"></a><h4>Creating Type Synonyms with Type Aliases</h4>
<p>Along with the newtype pattern, Rust provides the ability to declare a <strong>type alias</strong> to give an existing type another name.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">Kilometers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">  </span><span class="c1">// the alias `Kilometers` is a synonym for `i32`
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="nc">Kilometers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;x + y = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Unlike the <code>Millimeters</code> and <code>Meters</code> types above, <code>Kilometers</code> is <strong>not</strong> a separate, <strong>new type</strong>. Values that have the type <code>Kilometers</code> will be treated the same as values of type <code>i32</code>.</p>
<p>A type alias makes codes more manageable by reducing the repetition.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">Thunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">f</span>: <span class="nc">Thunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="o">|</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_long_type</span><span class="p">(</span><span class="n">f</span>: <span class="nc">Thunk</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">returns_long_type</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Thunk</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>It is also commonly used in the <code>std::io</code> module.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="the-never-type-that-never-returns"></a><h4>The Never Type that Never Returns</h4>
<p><code>!</code>, the <code>never type</code>, stands in the place of the return type when a function will never return.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// the function `bar` returns never.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>What the <code>never type</code> used for?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">guess</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="p">.</span><span class="n">trim</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="k">continue</span><span class="w"></span><span class="nl"></span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>continue</code> has a <code>!</code> value, or the code can&rsquo;t compile because <code>match</code> arms must all return the same type. Because <code>!</code> can never have a value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can be <strong>coerced into any other type</strong>.</p>
<p><code>panic!</code> macro is a useful never type as well.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;called `Option::unwrap()` on a `None` value&#34;</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>One final expression that has the type <code>!</code> is a loop:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">print</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;forever &#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// the loop never ends, so `!` is the value of the expression
</span><span class="c1"></span><span class="w">    </span><span class="n">print</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;and ever &#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="dynamically-sized-types-and-the-sized-trait"></a><h4>Dynamically Sized Types and the <code>Sized</code> Trait</h4>
<p>Due to Rust’s need to know certain details, such as how much space to allocate for a value of a particular type, there is a corner of its type system that can be confusing: the concept of <strong>dynamically sized types</strong>. Sometimes referred to as DSTs or unsized types, these types let us write code using values whose <strong>size</strong> we can know only <strong>at runtime</strong>.</p>
<p><strong>The dynamically sized type, <code>str</code></strong></p>
<p>Not <code>&amp;str</code>, but <code>str</code> on its own, is a DST. We can’t know how long the string is until runtime, meaning we can’t create a variable of type <code>str</code>, nor can we take an argument of type <code>str</code>.</p>
<p>So what do we do? We can make the type a <code>&amp;str</code> rather than a <code>str</code>. The slice data structure stores the starting position and the length of the slice.</p>
<p>The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a <strong>pointer</strong> of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or <code>Rc&lt;str&gt;</code>. Every trait is a dynamically sized type we can refer to by using the name of the trait. To use traits as trait objects, we must put them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> would work too).</p>
<p>To work with DSTs, Rust has a particular trait called the <code>Sized</code> trait to determine whether or not a type’s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function. That is, a generic function definition like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// same as `fn generic&lt;T: Sized&gt;(t: T)`
</span><span class="c1"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>By default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>A trait bound on <code>?Sized</code> is the <strong>opposite</strong> of a trait bound on <code>Sized</code>: we would read this as “T may or may not be Sized.” <strong>This syntax is only available for <code>Sized</code>, not any other traits.</strong></p>
<p>Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>. Because the type might not be <code>Sized</code>, we need to use it behind some kind of pointer. In this case, we’ve chosen a reference.</p>
<a class="post-dummy-target" id="195-advanced-functions-and-closures"></a><h3>19.5 Advanced Functions and Closures</h3>
<a class="post-dummy-target" id="function-pointers"></a><h4>Function Pointers</h4>
<p>Closures can be passed to functions. Regular functions can too, via <strong>function pointers</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">f</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">  </span><span class="c1">// `fn` type is function pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_twice</span><span class="p">(</span><span class="n">add_one</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The answer is: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the parameter type directly rather than declaring a generic type parameter with one of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>), so you can <strong>always pass</strong> a function pointer as an argument for a function that expects a closure. It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</p>
<p>An example of where you would want to <strong>only accept <code>fn</code> and not closures</strong> is when interfacing with external code that doesn’t have closures: <code>C</code> functions can accept functions as arguments, but <code>C</code> doesn’t have closures.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">list_of_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">list_of_strings</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_of_numbers</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="n">collect</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">list_of_strings</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_of_numbers</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">)</span><span class="w">  </span><span class="c1">// using a function pointer
</span><span class="c1"></span><span class="w">    </span><span class="p">.</span><span class="n">collect</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use <code>()</code> as initializer syntax, which looks like a <strong>function call</strong>. The initializers are actually implemented as functions returning an instance that’s constructed from their arguments. <strong>We can use these initializer functions as function pointers that implement the closure traits</strong>, which means we can specify the initializer functions as arguments for methods that take closures, like so:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Status</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Value</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Stop</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">list_of_statuses</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Status</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="mi">0</span><span class="k">u32</span><span class="p">.</span><span class="p">.</span><span class="mi">20</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">Status</span>::<span class="n">Value</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">.</span><span class="n">collect</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Some people prefer this style, and some people prefer to use closures. They <strong>compile to the same code</strong>, so use whichever style is clearer to you.</p>
<a class="post-dummy-target" id="returning-closures"></a><h4>Returning Closures</h4>
<p>Closures are represented by traits, which means you <strong>can’t return closures directly</strong>. In most cases where you might want to return a trait, you can instead use the <strong>concrete type</strong> that implements the trait as the return value of the function. But you can’t do that with closures because they don’t have a concrete type that is returnable; you’re not allowed to use the function pointer <code>fn</code> as a return type, for example.</p>
<p>The following code tries to return a closure directly, but it won’t compile:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The compiler error is as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + &#39;static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + &#39;static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + &#39;static`
  = note: the return type of a function must have a statically known size
</code></pre></td></tr></table>
</div>
</div><p>The error references the <code>Sized</code> trait again! Rust doesn’t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a <strong>trait object</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">(</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="196-macros"></a><h3>19.6 Macros</h3>
<p>The term <code>macro</code> refers to a family of features in Rust: <code>declarative</code> macros with <code>macro_rules!</code> and three kinds of <code>procedural</code> macros:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the derive attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
<a class="post-dummy-target" id="the-difference-between-macros-and-functions"></a><h4>The Difference Between Macros and Functions</h4>
<p>Fundamentally, macros are a way of writing code that writes other code, which is known as <strong>metaprogramming</strong>.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t.</p>
<p>A function signature must declare the <strong>number</strong> and type of parameters the function has. Macros, on the other hand, can take a <strong>variable number</strong> of parameters: we can call <code>println!(&quot;hello&quot;)</code> with one argument or <code>println!(&quot;hello {}&quot;, name)</code> with two arguments. Also, <strong>macros are expanded before the compiler interprets the meaning of the code</strong>, so a macro can, for example, <strong>implement a trait</strong> on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.</p>
<p>The <strong>downside</strong> to implementing a macro instead of a function is that macro <strong>definitions are more complex</strong> than function definitions because <strong>you’re writing Rust code that writes Rust code.</strong> Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</p>
<p>Another important difference between macros and functions is that you must <strong>define macros or bring them into scope before you call them in a file</strong>, as opposed to functions you can define anywhere and call anywhere.</p>
<a class="post-dummy-target" id="declarative-macros-with-macro_rules-for-general-metaprogramming"></a><h4>Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">macro_export</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">)</span><span class="p">,</span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">temp_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="cp">$(</span><span class="w">
</span><span class="w"></span><span class="w">                </span><span class="n">temp_vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="cp">$x</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="p">)</span><span class="o">*</span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="n">temp_vec</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="w">            </span><span class="cm">/*</span><span class="cm">
</span><span class="cm">            let mut temp_vec = Vec::new();
</span><span class="cm">            temp_vec.push(1);
</span><span class="cm">            temp_vec.push(2);
</span><span class="cm">            temp_vec.push(3);
</span><span class="cm">            temp_vec
</span><span class="cm">            </span><span class="cm">*/</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="procedural-macros-for-generating-code-from-attributes"></a><h4>Procedural Macros for Generating Code from Attributes</h4>
<p>The second form of macros is <strong>procedural macros</strong>, which act more like <strong>functions</strong> (and are a type of procedure). Procedural macros accept some <strong>code as an input</strong>, <strong>operate</strong> on that code, and produce some <strong>code as an output</strong> rather than matching against patterns and replacing the code with other code as declarative macros do.</p>
<p>Three kinds:</p>
<ul>
<li>Custom derive</li>
<li>Attribute-like</li>
<li>Function-like</li>
</ul>
<p>When creating procedural macros, the definitions must reside in their own crate with a special crate type.</p>
<a class="post-dummy-target" id="how-to-write-a-custom-derive-macro"></a><h4>How to Write a Custom <code>derive</code> Macro</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">hello_macro</span>::<span class="n">HelloMacro</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">hello_macro_derive</span>::<span class="n">HelloMacro</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="c1">// Annotate their type with `#[derive(HelloMacro)]` to get a default implementation of the `hello_macro` function.
</span><span class="c1"></span><span class="cp">#[</span><span class="cp">derive(HelloMacro)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Pancakes</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="n">Pancakes</span>::<span class="n">hello_macro</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="c1">// Prints: Hello, Macro! My name is Pancakes!
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// src/lib.rs
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">HelloMacro</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>If we don&rsquo;t use <code>derive</code>, we need to write the implementation block for each type we wanted to use with <code>hello_macro</code>, like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// If there is a type `struct Pie`, we need to `impl HelloMacro for Pie`.
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">HelloMacro</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pancakes</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="w">        </span><span class="c1">// Because the type name is used here, `hello_macro` with default
</span><span class="c1"></span><span class="w">        </span><span class="c1">// implementation can&#39;t do it.
</span><span class="c1"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hello, Macro! My name is Pancakes!&#34;</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>We can’t yet provide the <code>hello_macro</code> function with <strong>default implementation</strong> that will print the <strong>name of the type</strong> the trait is implemented on: <strong>Rust doesn’t have reflection capabilities</strong>, so it <strong>can’t look up the type’s name at runtime</strong>. We need a macro to generate code at compile time.</p>
<p>Refer to <code>ch19-06</code> about the implementation of <code>derive</code> macro.</p>
<a class="post-dummy-target" id="attribute-like-macros"></a><h4>Attribute-like macros</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">route(GET, </span><span class="s">&#34;</span><span class="s">/</span><span class="s">&#34;</span><span class="cp">)</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This <code>#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">proc_macro_attribute</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">route</span><span class="p">(</span><span class="n">attr</span>: <span class="nc">TokenStream</span><span class="p">,</span><span class="w"> </span><span class="n">item</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The first <code>TokenStream</code> is for the contents of the attribute: the <code>GET, &quot;/&quot;</code> part. The second is the body of the item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest of the <strong>function’s body</strong>.</p>
<a class="post-dummy-target" id="function-like-macros"></a><h4>Function-like macros</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">sql</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sql</span><span class="o">!</span><span class="p">(</span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">posts</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Defination of <code>sql!</code> macro:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[</span><span class="cp">proc_macro</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">sql</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="20-final-project-building-a-multithreaded-web-server"></a><h3>20 Final Project: Building a Multithreaded Web Server</h3>
<p>Rather than spawning unlimited threads, we’ll have a <strong>fixed number of threads waiting in the pool</strong>. As requests come in, they’ll be sent to the pool for processing. The pool will maintain a queue of incoming requests. Each of the threads in the pool will pop off a request from this queue, handle the request, and then ask the queue for another request. With this design, we can process N requests concurrently, where N is the number of threads. If each thread is responding to a long-running request, subsequent requests can still back up in the queue, but we’ve increased the number of long-running requests we can handle before reaching that point.</p>
<p>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the <strong>fork/join model</strong> and the <strong>single-threaded async I/O model</strong>. If you’re interested in this topic, you can read more about other solutions and try to implement them in Rust; with a low-level language like Rust, all of these options are possible.</p>
<p>Before we begin implementing a thread pool, let’s talk about what using the pool should look like. When you’re trying to design code, <strong>writing the client interface first</strong> can help guide your design. Write the API of the code so it’s structured in the way you want to call it; <strong>then implement the functionality within that structure</strong> rather than implementing the functionality and then designing the public API.</p>
<p>Similar to how we used test-driven development in the project in Chapter 12, we’ll use <strong>compiler-driven development</strong> here. We’ll write the code that calls the functions we want, and then we’ll look at errors from the compiler to determine what we should change next to get the code to work.</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>The article was updated on 2020-02-10</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share"><span></span></div>
        </div>
    </div>

    <div class="post-info-more">
        <section><span class="tag">
                        <a href="https://murray-liang.github.io/forgetful/tags/rust/"><i class="fas fa-tag fa-fw"></i>&nbsp;rust</a>&nbsp;
                    </span><span class="tag">
                        <a href="https://murray-liang.github.io/forgetful/tags/the-rust-programming-language/"><i class="fas fa-tag fa-fw"></i>&nbsp;the rust programming language</a>&nbsp;
                    </span><span class="tag">
                        <a href="https://murray-liang.github.io/forgetful/tags/trpl/"><i class="fas fa-tag fa-fw"></i>&nbsp;trpl</a>&nbsp;
                    </span></section>
        <section>
            <span><a href="javascript:window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="https://murray-liang.github.io/forgetful">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="https://murray-liang.github.io/forgetful/2020/02/tooz/" class="prev" rel="prev" title="Tooz"><i class="fas fa-angle-left fa-fw"></i>Tooz</a>
            <a href="https://murray-liang.github.io/forgetful/2020/02/design-topics/" class="next" rel="next" title="System Design Topics">System Design Topics<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div class="post-comment"></div>
    </article></div>
            </main><footer class="footer">
    <div class="copyright"><div class="copyright-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a>
        </div>

        <div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/Murray-LIANG" target="_blank">Murray-LIANG</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
    </div>
</footer>
</div><a href="#" class="dynamic-to-top" id="dynamic-to-top" data-scroll>
            <span>&nbsp;</span>
        </a><script src="/forgetful/js/lib/jquery/jquery.slim.min.js"></script><script src="/forgetful/js/lib/lazysizes/lazysizes.min.js"></script><script src="/forgetful/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js"></script><script>window.scroll = new SmoothScroll('[data-scroll]', {speed: 300, speedAsDuration: true});</script><link rel="stylesheet" href="/forgetful/css/lib/katex/katex.min.css"><script src="/forgetful/js/lib/katex/katex.min.js"></script><script defer src="/forgetful/js/lib/katex/auto-render.min.js"></script><link rel="stylesheet" href="/forgetful/css/lib/katex/copy-tex.min.css"><script defer src="/forgetful/js/lib/katex/copy-tex.min.js"></script><script defer src="/forgetful/js/lib/katex/mhchem.min.js"></script><script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "\\(", right: "\\)", display: false },
                    { left: "\\[", right: "\\]", display: true },{ left: "$", right: "$", display: false },]
            });
        });
    </script><script src="/forgetful/js/blog.min.js"></script>
</body>
</html>
